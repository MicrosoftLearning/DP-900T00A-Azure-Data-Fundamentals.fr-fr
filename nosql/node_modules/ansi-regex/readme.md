---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051665"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-regex [![État de la build](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> Expression régulière pour les [codes d’échappement ANSI](http://en.wikipedia.org/wiki/ANSI_escape_code) correspondants


## <a name="install"></a>Installer

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>Usage

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>Questions fréquentes (FAQ)

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>Pourquoi testez-vous des codes qui ne sont pas dans la norme ECMA 48 ?

Certains des codes que nous exécutons pour le test sont des codes que nous avons acquis parmi diverses listes de codes spécifiques non standard ou de fabricant. Si je me souviens bien, nous testons les codes standard et non standard, car la plupart d’entre eux ont le même format ou un format similaire et peuvent être mis en correspondance en toute sécurité dans les chaînes sans risque de supprimer le contenu existant des chaînes. Il existe quelques codes de contrôle non standard qui ne suivent pas le format traditionnel (ils se terminent par des nombres). Cela nous oblige à les exclure du test, car nous ne pouvons pas les faire correspondre de manière fiable.

D’un point de vue historique, ces normes ECMA ont été établies au début des années 90 alors que la VT100, par exemple, a été conçue entre le milieu et la fin des années 70. À cette époque, les codes de contrôle n’étaient pas encore très bien régis, et les ingénieurs les utilisaient pour une multitude de choses, comme activer des ports matériels, éventuellement propriétaires. Ailleurs, vous voyez une « anarchie » similaire de codes dans l’architecture x86 pour les processeurs. Il y a une multitude d’« interruptions » qui peuvent avoir des significations différentes selon les marques de processeurs, dont la plupart ont disparu.


## <a name="license"></a>Licence

MIT © [Sindre Sorhus](http://sindresorhus.com)
