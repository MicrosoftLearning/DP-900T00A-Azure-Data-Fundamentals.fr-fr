---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051737"
---
<a name="aproba"></a>aproba
======

Validateur extrêmement léger des arguments de fonction

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

Les types valides sont :

| type | description
| :--: | :----------
| *    | correspond à n’importe quel type
| A    | `Array.isArray` OU un objet `arguments`
| S    | typeof == chaîne
| N    | typeof == nombre
| F    | typeof == fonction
| O    | typeof == objet hors type A et type E
| B    | typeof == booléen
| E    | `instanceof Error` OU `null` **(spécial : voir ci-dessous)**
| Z    | == `null`

Les échecs de validation lèvent l’un de ces trois types d’exceptions, distingués par leur propriété `code` : `EMISSINGARG`, `EINVALIDTYPE` ou `ETOOMANYARGS`.

Si vous passez un type non valide, celui-ci est levé avec le code `EUNKNOWNTYPE`.

Si un argument **error** est trouvé et n’est pas Null, les arguments restants sont facultatifs.  Donc, si vous spécifiez `ESO`, cela revient à utiliser un `E` non magique dans `E|ESO|ZSO`.

### <a name="but-i-have-optional-arguments"></a>Mais j’ai des arguments facultatifs !

Vous pouvez fournir plusieurs signatures en les séparant par des tubes `|`.
Si une signature correspond aux arguments, ceux-ci seront considérés comme valides.

Par exemple, supposons que vous vouliez écrire une signature pour `fs.createWriteStream`.  Cela est documenté de cette manière :

```
fs.createWriteStream(path[, options])
```

Ce serait une signature de `SO|S`,  à savoir une chaîne et un objet, ou juste une chaîne.

Maintenant, si vous lisez la documentation `fs` complète, vous voyez que le chemin peut AUSSI être un buffer.  Et les options peuvent être une chaîne, comme ceci :
```
path <String> | <Buffer>
options <String> | <Object>
```

Pour reproduire cela, vous devez énumérer entièrement toutes les combinaisons possibles, et cela nécessite la signature de `SO|SS|OO|OS|S|O`.  Ce n’est pas très commode : quand vous faites ce genre de choses, cela ajoute de la complexité à votre API.


### <a name="browser-support"></a>Prise en charge des navigateurs

Ce validateur n’a pas de dépendances et doit en principe fonctionner dans les navigateurs. Vous aurez toutefois des traces de pile plus bruyantes.

### <a name="why-this-exists"></a>Pourquoi ce validateur ?

Je voulais un validateur d’arguments très simple. Il devait remplir ces deux critères :

1. Être plus concis et plus facile à utiliser que les assertions

2. Ne pas encourager un prétraitement infini des DSL

Cela explique pourquoi les types sont spécifiés par un caractère unique et qu’il n’y a pas d’argument facultatif, notamment. 

Ce validateur n’est pas destiné à valider les données utilisateur. Il sert spécifiquement à l’assertion de l’interface de vos fonctions.

Si vous avez besoin de validations supplémentaires, je vous encourage à les écrire à la main ou à trouver un autre moyen.

