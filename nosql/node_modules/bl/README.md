---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051385"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![État de la build](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Collecteur, lecteur et streamer de listes de buffers Node.js.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** est un objet utilisé pour le stockage des collections de buffers Node, en vue de les exposer avec l’API Buffer principale accessible en lecture. Vous pouvez également l’utiliser comme un flux duplex pour collecter les buffers à partir d’un flux qui les envoie, et envoyer les buffers vers un flux qui les consomme.

Les buffers initiaux sont conservés à l’identique et seules les copies nécessaires sont effectuées. Les lectures qui nécessitent l’utilisation d’un seul buffer initial retournent uniquement une partie de ce buffer (qui référence la même mémoire que le buffer initial). Les lectures qui s’étendent sur plusieurs buffers effectuent des opérations de concaténation selon les besoins et retournent les résultats de manière transparente.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Ajoutez un rappel (callback) dans le constructeur et utilisez-le simplement comme **[concat-stream](https://github.com/maxogden/node-concat-stream)**  :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Notez que lorsque vous utilisez la méthode *callback* de cette façon, le paramètre `data` résultant est une concaténation de tous les objets `Buffer` dans la liste. Si vous souhaitez éviter la surcharge de cette concaténation (en cas de forte sensibilisation aux performances), n’utilisez pas la méthode *callback* et écoutez simplement `'end'` à la place, comme un flux standard.

Ou pour extraire une URL avec [hyperquest](https://github.com/substack/hyperquest) (fonctionne normalement avec [request](http://github.com/mikeal/request) et même le HTTP Node standard !) :

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

Vous pouvez aussi l’utiliser comme flux accessible en lecture pour recomposer une liste de buffers vers une source de sortie :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
Aucun argument n’est _obligatoire_ pour le constructeur, mais vous pouvez initialiser la liste en passant un objet `Buffer` unique ou un tableau d’objets `Buffer`.

`new` n’est pas strictement obligatoire. Si vous n’instanciez pas un nouvel objet, cela sera effectué automatiquement pour vous permettre de créer une instance simplement comme ceci :

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Détermine si l’objet passé est un `BufferList`. Il retourne `true` si l’objet passé est une instance de `BufferList` **ou** de `BufferListStream` ; sinon, il retourne `false`.

Remarque : Il ne retourne pas `true` pour les instances de `BufferList` ou de `BufferListStream` qui ont été créées par des versions de cette bibliothèque avant l’ajout de cette méthode statique.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Obtient la longueur de la liste, en octets. Cela correspond à la somme des longueurs de tous les buffers contenus dans la liste, moins tout décalage initial pour un buffer semi-consommé au début. Doit représenter avec exactitude le nombre total d’octets pouvant être lus dans la liste.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` ajoute un buffer ou un BufferList supplémentaire à la liste interne. `this` est retourné afin qu’il puisse être chaîné.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` retourne l’octet à l’index spécifié.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` retourne l’octet à l’index spécifié.
La méthode `indexOf()` retourne le premier index auquel un élément donné peut être trouvé dans le BufferList, ou la valeur -1 si l’élément n’est pas présent.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` retourne un nouvel objet `Buffer` contenant les octets dans la plage spécifiée. Les deux arguments `start` et `end` sont facultatifs et référencent par défaut le début et la fin de la liste, respectivement.

Si la plage demandée s’étend sur un seul buffer interne, une partie de ce buffer est retournée, qui partage la plage mémoire initiale de ce buffer. Si la plage s’étend sur plusieurs buffers, des opérations de copie seront probablement effectuées pour donner un buffer uniforme.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` retourne un nouvel objet `BufferList` contenant les octets dans la plage spécifiée. Les deux arguments `start` et `end` sont facultatifs et référencent par défaut le début et la fin de la liste, respectivement.

Aucune copie ne sera effectuée. Tous les buffers dans le résultat partagent la mémoire avec la liste initiale.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` copie le contenu de la liste vers le buffer `dest`, à partir de `destStart` et avec les octets contenus dans la plage spécifiée par `srcStart` et `srcEnd`. Les arguments `destStart`, `start` et `end` sont facultatifs et référencent par défaut le début du buffer `dest`, et le début et la fin de la liste, respectivement.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` effectue une opération **shallow-copy** de la liste. Les buffers internes sont conservés à l’identique. Par conséquent, si vous changez les buffers sous-jacents, la modification sera répercutée à la fois dans le buffer initial et dans le buffer copié. Vous devez utiliser cette méthode si vous souhaitez appeler `consume()` ou `pipe()` tout en conservant la liste initiale. Exemple :

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` décale les octets *à partir du début de la liste*. Le nombre d’octets consommés ne doit pas obligatoirement être aligné sur les tailles des buffers internes : en effet, les décalages initiaux sont calculés en conséquence pour vous donner une vue cohérente des données.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` retourne une représentation du buffer, sous forme de chaîne. Les arguments facultatifs `start` et `end` sont passés à `slice()`, et l’argument `encoding` est passé à `toString()` dans le buffer résultant. Pour plus d’informations, consultez la documentation [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end).

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Toutes les méthodes de lecture d’octets standard de l’interface `Buffer` sont implémentées et s’exécutent de manière transparente entre les limites des buffers internes.

Pour plus d’informations, consultez la documentation <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b>.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** est un **[flux Duplex](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** dans Node. Il peut donc être lu et écrit comme un flux Node standard. Vous pouvez également faire une opération `pipe()` vers et à partir d’une instance **BufferListStream**.

Le constructeur prend un callback facultatif. S’il est fourni, le callback est appelé avec un argument error suivi d’une référence à l’instance **bl**, quand `bl.end()` est appelé (à partir d’un flux redirigé). C’est une méthode pratique pour collecter l’ensemble du contenu d’un flux, en particulier lorsque le flux est *volumineux*, comme c’est le cas avec un flux réseau.

Normalement, aucun argument n’est obligatoire pour le constructeur, mais vous pouvez initialiser la liste en passant un objet `Buffer` unique ou un tableau d’objets `Buffer`.

`new` n’est pas strictement obligatoire. Si vous n’instanciez pas un nouvel objet, cela sera effectué automatiquement pour vous permettre de créer une instance simplement comme ceci :

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

Remarque : Pour des raisons de compatibilité descendante, `BufferListStream` est l’exportation **par défaut** lorsque vous utilisez `require('bl')` :

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Contributeurs

**bl** vous est proposé par les hackers suivants :

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Licence et droits d’auteur

Copyright (c) 2013-2019, Contributeurs bl (listés ci-dessus).

bl est concédé sous licence MIT. Tous les droits qui ne sont pas explicitement accordés dans le cadre de la licence MIT sont réservés. Pour plus d’informations, consultez le fichier LICENSE.md fourni.
