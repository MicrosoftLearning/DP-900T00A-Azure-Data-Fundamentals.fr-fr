---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051382"
---
# <a name="combined-stream"></a>combined-stream

Flux qui émet plusieurs autres flux l’un après l’autre.

**Remarque** Actuellement, `combined-stream` fonctionne uniquement avec les flux de version 1. Nous tentons actuellement de basculer cette bibliothèque vers les flux de version 2. Toute aide est la bienvenue. :) Entre temps, vous pouvez explorer d’autres bibliothèques qui fournissent la prise en charge des flux de version 2 avec plus ou moins de compatibilité avec `combined-stream`.

- [combined-stream2](https://www.npmjs.com/package/combined-stream2) : remplacement compatible streams2 pour le module combined-stream.

- [multistream](https://www.npmjs.com/package/multistream) : flux qui émet plusieurs autres flux l’un après l’autre.

## <a name="installation"></a>Installation

``` bash
npm install combined-stream
```

## <a name="usage"></a>Usage

Voici un exemple simple qui montre comment utiliser combined-stream pour combiner deux fichiers en un :

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Bien que l’exemple ci-dessus fonctionne correctement, il interrompt tous les flux sources jusqu’à ce qu’ils soient nécessaires. Si vous ne souhaitez pas que cela se produise, vous pouvez affecter la valeur `false` à `pauseStreams` :

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Toutefois, que se passe-t-il si vous n’avez pas encore tous les flux sources ou si vous ne souhaitez pas leur allouer les ressources (descripteurs de fichiers, mémoire, etc.) immédiatement ?
Dans ce cas, vous pouvez simplement fournir un rappel qui fournit le flux en appelant une fonction `next()` :

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

Retourne un nouvel objet de flux combiné. Options disponibles :

* `maxDataSize`
* `pauseStreams`

L’effet de ces options est décrit ci-dessous.

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

Indique s’il faut appliquer la régulation de flux aux flux sous-jacents. Si la valeur est `false`, les flux sous-jacents ne seront jamais suspendus. Si la valeur est `true`, les flux sous-jacents seront suspendus juste après avoir été ajoutés et lorsque `delayedStream.pipe()` souhaite limiter.

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

Quantité maximale d’octets (ou de caractères) à mettre en mémoire tampon pour tous les flux sources.
Si cette valeur est dépassée, `combinedStream` émet un événement `'error'`.

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

Quantité d’octets (ou de caractères) actuellement mis en mémoire tampon par `combinedStream`.

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

Ajoute le `stream` donné à l’objet combinedStream. Si `pauseStreams` a la valeur true, ce flux sera également suspendu immédiatement.

`streams` peut également être une fonction qui accepte un paramètre nommé `next`. `next` est une fonction qui doit être appelée pour fournir le flux `next` ; voir l’exemple ci-dessus.

Quel que soit le mode d’ajout de `stream`, combined-stream y attache toujours un écouteur `'error'`, de sorte que vous n’avez pas à le faire manuellement.

Cas spécial : `stream` peut également être une chaîne ou une mémoire tampon.

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

Vous ne devez pas appeler cette fonction ; `combinedStream` prend soin de piper les flux ajoutés dans lui-même pour vous.

### <a name="combinedstreamresume"></a>combinedStream.resume()

Fait en sorte que `combinedStream` commence le drainage des flux qu’il gère. La fonction est idempotente, et émet également à chaque fois un événement `'resume'`, qui va généralement dans le flux qui est actuellement drainé.

### <a name="combinedstreampause"></a>combinedStream.pause();

Si `combinedStream.pauseStreams` a la valeur `false`, cela ne fait rien.
Sinon, un événement `'pause'` est émis, qui va dans le flux qui est actuellement drainé ; vous pouvez ainsi l’utiliser pour appliquer la régulation du flux.

### <a name="combinedstreamend"></a>combinedStream.end();

Affecte la valeur false à `combinedStream.writable`, émet un événement `'end'` et retire tous les flux de la file d’attente.

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

Identique à `combinedStream.end()`, sauf qu’elle émet un événement `'close'` plutôt que `'end'`.

## <a name="license"></a>Licence

combined-stream est concédé sous licence MIT.
