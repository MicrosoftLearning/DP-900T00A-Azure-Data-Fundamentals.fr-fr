---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051262"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — pure-JavaScript BigInts [![État de la build](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi)[![jsbi sur npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI est une implémentation Pure-JavaScript de la [proposition BigInt ECMAScript](https://tc39.es/proposal-bigint/), qui est officiellement devenue une partie du langage JavaScript dans ES2020.

## <a name="installation"></a>Installation

```sh
npm install jsbi --save
```

## <a name="usage"></a>Usage

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

Remarque : Appelez `toString` explicitement sur toutes les instances `JSBI` lorsque vous les `console.log()` afin de voir leur représentation numérique (par exemple `String(max)` ou `max.toString()`). Sans lui (par exemple `console.log(max)`), vous verrez à la place l’objet qui représente la valeur.

Utilisez [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) pour transpiler du code JSBI en code BigInt natif.

Pour plus d’informations, consultez les instructions détaillées ci-dessous.

## <a name="why"></a>Pourquoi ?

[Les BigInts natifs sont déjà fournis](https://v8.dev/features/bigint) avec les navigateurs modernes (à la date de rédaction de cet article, Google Chrome 67+, Opera 54+, Firefox 68+) et Node.js (v10.4+), et ils sont censés arriver dans d’autres navigateurs à l’avenir, ce qui signifie que vous ne pouvez pas encore les utiliser si vous souhaitez que votre code s’exécute partout.

Pour utiliser des bigInts dans votre code aujourd’hui, vous avez besoin d’une bibliothèque. Mais il y a une difficulté : la proposition BigInt modifie le comportement des opérateurs (comme `+`, `>=`, etc.) afin qu’ils fonctionnent sur les BigInts. Ces modifications sont impossibles à polyfiller directement ; et ils rendent également infaisable (dans la plupart des cas) la transpilation du code BigInt en code de secours à l’aide de Babel ou d’outils similaires. En effet, une telle transpilation devrait remplacer chaque opérateur dans le programme par un appel à une fonction qui effectue des vérifications de type sur ses entrées, ce qui entraînerait une pénalité de performances inacceptable.

La solution consiste à procéder de manière inverse : écrire du code à l’aide de la syntaxe d’une bibliothèque et le [transpiler en code BigInt natif ](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) lorsqu’il est disponible. JSBI est conçu exactement dans ce but : il fournit une implémentation de « polyfill » BigInt qui se comporte exactement comme les BigInts natifs à venir, mais avec une syntaxe que vous pouvez inclure aujourd’hui sur tous les navigateurs.

Ses avantages par rapport aux autres bibliothèques big-integer existantes sont les suivants :

- Il se comporte exactement comme le feront les BigInts natifs quand ils seront disponibles. Ainsi, pour migrer vers ceux-ci, vous pouvez mettre à jour [mécaniquement](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) la syntaxe de votre code ; il ne sera pas nécessaire de repenser toute sa logique.
- Fort accent sur les performances. En moyenne, JSBI est compétitif en matière de performances avec l’implémentation native proposée actuellement par Google Chrome.

## <a name="how"></a>Comment faire ?

À l’exception des différences mécaniques de syntaxe, vous utilisez les BigInts JSBI [comme vous utiliseriez les BigInts natifs](https://developers.google.com/web/updates/2018/05/bigint). Certaines choses ont même une apparence identique, après le remplacement de `BigInt` par `JSBI.BigInt` :

| Opération            | BigInts natifs          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| Création à partir d’une chaîne | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| Création à partir d’un nombre | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| Conversion en chaîne | `a.toString(radix)`     | `a.toString(radix)`      |
| Conversion en nombre | `Number(a)`             | `JSBI.toNumber(a)`       |
| Troncation           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| Vérification de type           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

La plupart des opérateurs sont remplacés par des appels de méthode :

| Opération                   | BigInts natifs | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| Addition                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| Soustraction                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| Multiplication              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| Division                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| Reste                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| Élévation à la puissance              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| Négation                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| Négation d'opération de bits            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| Décalage vers la gauche               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| Décalage vers la droite              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| « and » au niveau du bit               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| « or » au niveau du bit                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| « xor » au niveau du bit               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| Comparaison avec d’autres BigInts | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

Les fonctions ci-dessus opèrent uniquement sur les BigInts. (Elles n’effectuent pas de vérification de type dans l’implémentation actuelle, car ces vérifications sont une perte de temps lorsque nous partons du principe que vous savez ce que vous faites. N’essayez pas de les appeler avec d’autres entrées, ou vous obtiendrez des échecs « intéressants » !)

Certaines opérations sont particulièrement intéressantes lorsque vous leur donnez des entrées de types mixtes, par exemple la comparaison d’un BigInt à un nombre ou la concaténation d’une chaîne avec un BigInt. Elles sont implémentées en tant que fonctions statiques nommées d’après les opérateurs natifs respectifs :

| Opération                       | BigInts natifs | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| Comparaison d’égalité abstraite    | `x == y`       | `JSBI.EQ(x, y)`  |
| « Non égal » générique             | `x != y`       | `JSBI.NE(x, y)`  |
| « Inférieur à » générique             | `x < y`        | `JSBI.LT(x, y)`  |
| « Inférieur ou égal à » générique    | `x <= y`       | `JSBI.LE(x, y)`  |
| « Supérieur à » générique          | `x > y`        | `JSBI.GT(x, y)`  |
| « Supérieur ou égal à » générique | `x >= y`       | `JSBI.GE(x, y)`  |
| Addition générique                | `x + y`        | `JSBI.ADD(x, y)` |

Les noms des variables `x` et `y` ici indiquent que les variables peuvent faire référence à n’importe quoi, par exemple `JSBI.GT(101.5, BigInt('100'))` ou `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

Malheureusement, il existe également quelques éléments qui ne sont pas du tout pris en charge :

| Opération non prise en charge | BigInts natifs | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| littéraux              | `a = 123n;`    | N/A ☹                                |
| incrément             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| décrément             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

Il est impossible de répliquer le comportement exact des opérateurs `++` et `--` natifs avec des fonctions statiques. JSBI étant finalement destiné à être transpilé, il ne fournit pas une alternative « similaire mais différente ». Vous pouvez utiliser `JSBI.add()` et `JSBI.subtract()` à la place.

## <a name="when"></a>Quand ?

Maintenant. La bibliothèque JSBI est utilisable dès aujourd’hui.

Une fois les BigInts pris en charge en mode natif partout, utilisez [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) pour transpiler votre code JSBI en code BigInt natif une fois pour toutes.

Consultez [notre suivi des problèmes](https://github.com/GoogleChromeLabs/jsbi/issues) pour en savoir plus sur nos futurs plans pour JSBI et rejoignez la discussion !

Un plan d’avenir plus vague consiste à utiliser la bibliothèque JSBI (ou une extension) comme terrain intermédiaire pour des fonctionnalités supplémentaires liées à BigInt. La proposition officielle est intentionnellement un peu minimale, et laisse d’autres « fonctions de bibliothèque » pour les propositions de suivi. Il s’agit par exemple d’une fonction `exp`+`mod` combinée et de fonctions de manipulation de bits.

## <a name="development"></a>Développement

1. Clonez ce dépôt et `cd` dans le répertoire local.

1. Utilisez la version Node.js spécifiée dans `.nvmrc` :

     ```sh
     nvm use
     ```

1. Installez les dépendances de développement :

    ```sh
    npm install
    ```

1. Exécutez les tests :

    ```sh
    npm test
    ```

    Consultez `npm run` pour obtenir la liste des commandes.

## <a name="for-maintainers"></a>Pour les responsables de maintenance

### <a name="how-to-publish-a-new-release"></a>Comment publier une nouvelle mise en production

1. Sur la branche `main`, placez le numéro de version dans `package.json` :

    ```sh
    npm version patch -m 'Release v%s'
    ```

    Au lieu de `patch`, utilisez `minor` ou `major` [si nécessaire](https://semver.org/).

    Notez que cela produit un commit + étiquette Git.

1. Poussez le commit et l’étiquette de mise en production :

    ```sh
    git push
    ```

    Notre CI publie ensuite automatiquement la nouvelle mise en production sur npm.
