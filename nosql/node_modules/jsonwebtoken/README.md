---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051478"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Créer** | **Dépendance** |
|-----------|---------------|
| [![État de la build](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![État des dépendances](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Implémentation de [jetons web JSON](https://tools.ietf.org/html/rfc7519).

Ceci a été développé par rapport à `draft-ietf-oauth-json-web-token-08`. Elle utilise [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>Installer

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Notes de migration

* [De v7 à v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Usage

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(Asynchrone) Si un rappel est fourni, le rappel est appelé avec le `err` ou le JWT.

(Synchrone) Retourne le jsonWebToken sous forme de chaîne

`payload` peut être un littéral d’objet, une mémoire tampon ou une chaîne représentant un JSON valide. 
> **_Notez_ que** `exp` ou toute autre revendication est définie uniquement si la charge utile est un littéral d’objet. Les charges utiles de mémoire tampon ou de chaîne ne sont pas vérifiées pour déterminer la validité du JSON.

> Si `payload` n’est pas une mémoire tampon ou une chaîne, elle est convertie de force en chaîne à l’aide de `JSON.stringify`.

`secretOrPrivateKey` est une chaîne, une mémoire tampon ou un objet contenant le secret pour les algorithmes HMAC, ou la clé privée encodée PEM pour RSA et ECDSA. Dans le cas d’une clé privée avec phrase secrète, un objet `{ key, passphrase }` peut être utilisé (en fonction de la [documentation sur le chiffrement](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)) ; dans ce cas, veillez à passer l’option `algorithm`.

`options`:

* `algorithm` (par défaut : `HS256`)
* `expiresIn` : exprimé en secondes, ou une chaîne décrivant un intervalle de temps [zeit/ms](https://github.com/zeit/ms). 
  > Par exemple : `60`, `"2 days"`, `"10h"`, `"7d"`. Une valeur numérique est interprétée comme un nombre de secondes. Si vous utilisez une chaîne, veillez à fournir les unités de temps (jours, heures, etc.), sinon l’unité milliseconde est utilisée par défaut (`"120"` est égal à `"120ms"`).
* `notBefore` : exprimé en secondes, ou une chaîne décrivant un intervalle de temps [zeit/ms](https://github.com/zeit/ms). 
  > Par exemple : `60`, `"2 days"`, `"10h"`, `"7d"`. Une valeur numérique est interprétée comme un nombre de secondes. Si vous utilisez une chaîne, veillez à fournir les unités de temps (jours, heures, etc.), sinon l’unité milliseconde est utilisée par défaut (`"120"` est égal à `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload` : si la valeur est true, la fonction de signature modifie directement l’objet de charge utile. Ceci est utile si vous avez besoin d’une référence brute à la charge utile une fois que des revendications y ont été appliquées, mais avant qu’elle ait été encodée dans un jeton.



> Il n’y a pas de valeurs par défaut pour `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`.  Ces revendications peuvent également être fournies dans la charge utile directement avec `exp`, `nbf`, `aud`, `sub` et `iss` respectivement, mais vous **_ne pouvez pas_** les inclure dans les deux emplacements.

N’oubliez pas que `exp`, `nbf` et `iat` sont **NumericDate** ; voir [Expiration de jeton (revendication exp)](#token-expiration-exp-claim)


L’en-tête peut être personnalisé via l’objet `options.header`.

Les jwts générés incluent une revendication `iat` (émise à) par défaut, sauf si `noTimestamp` est spécifié. Si `iat` est inséré dans la charge utile, il sera utilisé à la place de l’horodatage réel pour calculer d’autres choses comme `exp` étant donné un intervalle de temps dans `options.expiresIn`.

Signature synchrone avec valeur par défaut (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Signature synchrone avec RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Signature asynchrone
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Antidater un jwt de 30 secondes
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Expiration de jeton (revendication exp)

La norme pour JWT définit une revendication `exp` pour l’expiration. L’expiration est représentée en tant que **NumericDate** :

> Valeur numérique JSON représentant le nombre de secondes depuis 1970-01-01T00:00:00Z UTC jusqu’à la date/heure UTC spécifiée, en ignorant les secondes intercalaires.  Cela équivaut à la définition IEEE Std 1003.1, 2013 Edition [POSIX.1] « Secondes depuis l’époque », dans laquelle chaque jour est représenté par exactement 86 400 secondes ; à part cela les valeurs non entières peuvent être représentées.  Consultez la RFC 3339 [RFC3339] pour plus d’informations sur les dates/heures en général, et sur UTC en particulier.

Cela signifie que le champ `exp` doit contenir le nombre de secondes depuis l’époque.

Signature d’un jeton avec une expiration d’une heure :

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Voici une autre façon de générer un jeton comme celui-ci avec cette bibliothèque :

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(Asynchrone) Si un rappel est fourni, la fonction agit de manière asynchrone. Le rappel est appelé avec la charge utile décodée si la signature est valide et que l’audience, l’émetteur ou l’expiration facultative sont valides. Si ce n’est pas le cas, il est appelé avec l’erreur.

(Synchrone) Si aucun rappel n’est fourni, la fonction agit de manière synchrone. Retourne la charge utile décodée si la signature est valide et que l’audience, l’émetteur ou l’expiration facultative sont valides. Si ce n’est pas le cas, l’erreur est levée.

`token` est la chaîne JsonWebToken

`secretOrPublicKey` est une chaîne ou une mémoire tampon contenant le secret pour les algorithmes HMAC, ou la clé publique encodée PEM pour RSA et ECDSA.
Si `jwt.verify` appelée de manière asynchrone, `secretOrPublicKey` peut être une fonction qui doit extraire le secret ou la clé publique. Voir ci-dessous pour obtenir un exemple détaillé

Comme mentionné dans [ce commentaire](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), il existe d’autres bibliothèques qui attendent des secrets codés en base64 (octets aléatoires encodés à l’aide de base64). Si c’est votre cas, vous pouvez passer `Buffer.from(secret, 'base64')` ; le secret sera alors décodé à l’aide de base64 et la vérification du jeton utilisera les octets aléatoires d’origine.

`options`

* `algorithms` : liste de chaînes avec les noms des algorithmes autorisés. Par exemple, `["HS256", "HS384"]`.
* `audience` : si vous souhaitez vérifier l’audience (`aud`), fournissez une valeur ici. L’audience peut être vérifiée par rapport à une chaîne, une expression régulière ou une liste de chaînes et/ou d’expressions régulières. 
  > Par exemple : `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete` : retourne un objet avec le `{ payload, header, signature }` décodé plutôt qu’uniquement le contenu habituel de la charge utile.
* `issuer` (facultatif) : chaîne ou tableau de chaînes de valeurs valides pour le champ `iss`.
* `ignoreExpiration` : si `true`, ne validez pas l’expiration du jeton.
* `ignoreNotBefore`...
* `subject` : si vous souhaitez vérifier l’objet (`sub`), fournissez une valeur ici
* `clockTolerance` : nombre de secondes à tolérer lors de la vérification des revendications `nbf` et `exp`, afin de gérer les petites différences d’horloge entre différents serveurs
* `maxAge` : âge maximal autorisé pour que les jetons restent valides. Il est exprimé en secondes ou sous forme de chaîne décrivant un intervalle de temps [zeit/ms](https://github.com/zeit/ms). 
  > Par exemple : `1000`, `"2 days"`, `"10h"`, `"7d"`. Une valeur numérique est interprétée comme un nombre de secondes. Si vous utilisez une chaîne, veillez à fournir les unités de temps (jours, heures, etc.), sinon l’unité milliseconde est utilisée par défaut (`"120"` est égal à `"120ms"`).
* `clockTimestamp` : heure en secondes qui doit être utilisée comme heure actuelle pour toutes les comparaisons nécessaires.
* `nonce` : si vous souhaitez vérifier la revendication `nonce`, fournissez ici une valeur de chaîne. Ceci est utilisé sur Open ID pour les jetons d’ID. ([Remarques relatives à l’implémentation Open ID](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(Synchrone) Retourne la charge utile décodée sans vérifier si la signature est valide.

> __Avertissement :__ Cela ne vérifie __pas__ si la signature est valide. Vous ne devez __pas__ l’utiliser pour les messages non approuvés. Vous souhaiterez probablement utiliser `jwt.verify` à la place.

`token` est la chaîne JsonWebToken

`options`:

* `json` : force JSON.parse sur la charge utile même si l’en-tête ne contient pas `"typ":"JWT"`.
* `complete` : retourne un objet avec l’en-tête et la charge utile décodée.

 Exemple

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Erreurs & codes
Erreurs levées possibles lors de la vérification.
L’erreur est le premier argument du rappel de vérification.

### <a name="tokenexpirederror"></a>TokenExpiredError

Erreur levée si le jeton a expiré.

Objet d’erreur :

* name : 'TokenExpiredError'
* message: 'jwt expired'
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Objet d’erreur :

* name : 'JsonWebTokenError'
* » correspondant :
  * 'jwt malformed'
  * 'jwt signature is required'
  * 'invalid signature'
  * 'jwt audience invalid. expected: [OPTIONS AUDIENCE]'
  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]'
  * 'jwt id invalid. expected: [OPTIONS JWT ID]'
  * 'jwt subject invalid. expected: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Levée si l’heure actuelle est antérieure à la revendication nbf.

Objet d’erreur :

* name : 'NotBeforeError'
* message: 'jwt not active'
* date : 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Algorithmes pris en charge

Tableau d’algorithmes pris en charge. Les algorithmes suivants sont actuellement pris en charge.

Valeur du paramètre alg | Signature numérique ou algorithme MAC
----------------|----------------------------
HS256 | HMAC qui utilise un algorithme de hachage SHA-256.
HS384 | HMAC qui utilise un algorithme de hachage SHA-384.
HS512 | HMAC qui utilise un algorithme de hachage SHA-512.
RS256 | RSASSA-PKCS1-v1_5 qui utilise un algorithme de hachage SHA-256
RS384 | RSASSA-PKCS1-v1_5 qui utilise un algorithme de hachage SHA-384
RS512 | RSASSA-PKCS1-v1_5 qui utilise un algorithme de hachage SHA-512
PS256 | RSASSA-PSS qui utilise un algorithme de hachage SHA-256 (uniquement Node ^6.12.0 OU >=8.0.0)
PS384 | RSASSA-PSS qui utilise un algorithme de hachage SHA-384 (uniquement Node ^6.12.0 OU >=8.0.0)
PS512 | RSASSA-PSS qui utilise un algorithme de hachage SHA-512 (uniquement Node ^6.12.0 OU >=8.0.0)
ES256 | ECDSA qui utilise la courbe P-256 et un algorithme de hachage SHA-256
ES384 | ECDSA qui utilise la courbe P-384 et un algorithme de hachage SHA-384
ES512 | ECDSA qui utilise la courbe P-521 et un algorithme de hachage SHA-512
Aucun | Aucune signature numérique ou valeur MAC n’est incluse

## <a name="refreshing-jwts"></a>Actualisation des JWT

Tout d’abord, nous vous recommandons de réfléchir soigneusement afin de savoir si l’actualisation automatique d’un JWT n’introduit aucune vulnérabilité dans votre système.

Nous préférons ne pas inclure cela dans la bibliothèque. Toutefois, vous pouvez examiner [cet exemple](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) pour voir comment cela pourrait être accompli.
Outre cet exemple, il existe [un problème](https://github.com/auth0/node-jsonwebtoken/issues/122) et [une demande de tirage](https://github.com/auth0/node-jsonwebtoken/pull/172) pour en savoir plus sur à ce sujet.

# <a name="todo"></a>TODO

* La chaîne de certificats X.509 n’est pas vérifiée

## <a name="issue-reporting"></a> Signalement de problèmes 

Si vous avez trouvé un bogue ou si vous avez une demande de fonctionnalité, signalez-les dans cette section sur les problèmes du dépôt. Ne signalez pas les failles de sécurité dans le suivi de problèmes GitHub public. Le [Programme de divulgation responsable](https://auth0.com/whitehat) détaille la procédure de divulgation des problèmes de sécurité.

## <a name="author"></a>Auteur

[Auth0](https://auth0.com)

## <a name="license"></a>Licence

Ce projet est concédé sous licence MIT. Pour plus d’informations, consultez le fichier [LICENSE](LICENSE) .
