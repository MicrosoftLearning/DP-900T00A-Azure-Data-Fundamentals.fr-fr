---
ms.openlocfilehash: cbc289a6b02d7acb0ad82e3a95bde8846fcff55e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050455"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![État de la build](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws)

Implémentation de [signatures web JSON](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Ceci a été développé sur `draft-ietf-jose-json-web-signature-08` et implémente l’ensemble de la spécification **à l’exception** de la signature/vérification de la chaîne de certificats X.509 (les correctifs sont les bienvenus).

Il existe des API synchrones (`jws.sign`, `jws.verify`) et de streaming (`jws.createSign`, `jws.createVerify`).

# <a name="install"></a>Installer

```bash
$ npm install jws
```

# <a name="usage"></a>Usage

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

Tableau d’algorithmes pris en charge. Les algorithmes suivants sont actuellement pris en charge.

Valeur du paramètre alg | Signature numérique ou algorithme MAC
----------------|----------------------------
HS256 | HMAC qui utilise un algorithme de hachage SHA-256.
HS384 | HMAC qui utilise un algorithme de hachage SHA-384.
HS512 | HMAC qui utilise un algorithme de hachage SHA-512.
RS256 | RSASSA qui utilise un algorithme de hachage SHA-256
RS384 | RSASSA qui utilise un algorithme de hachage SHA-384
RS512 | RSASSA qui utilise un algorithme de hachage SHA-512
PS256 | RSASSA-PSS qui utilise un algorithme de hachage SHA-256
PS384 | RSASSA-PSS qui utilise un algorithme de hachage SHA-384
PS512 | RSASSA-PSS qui utilise un algorithme de hachage SHA-512
ES256 | ECDSA qui utilise la courbe P-256 et un algorithme de hachage SHA-256
ES384 | ECDSA qui utilise la courbe P-384 et un algorithme de hachage SHA-384
ES512 | ECDSA qui utilise la courbe P-521 et un algorithme de hachage SHA-512
Aucun | Aucune signature numérique ou valeur MAC n’est incluse

## <a name="jwssignoptions"></a>jws.sign(options)

(Synchrone) Retourne une signature web JSON pour un en-tête et une charge utile.

Options :

* `header`
* `payload`
* `secret` ou `privateKey`
* `encoding` (Facultatif) La valeur par défaut est « utf8 ».

`header` doit être un objet avec une propriété `alg`. `header.alg` doit être une valeur trouvée dans `jws.ALGORITHMS`. Voir le tableau des algorithmes pris en charge ci-dessus.

Si `payload` n’est pas une mémoire tampon ou une chaîne, elle est convertie de force en chaîne à l’aide de `JSON.stringify`.

Exemple

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

(Synchrone) Retourne `true` ou `false` pour indiquer si une signature correspond à un secret ou à une clé.

`signature` est une signature JWS. `header.alg` doit être une valeur trouvée dans `jws.ALGORITHMS`.
Voir le tableau des algorithmes pris en charge ci-dessus. `secretOrKey` est une chaîne ou une mémoire tampon contenant le secret pour les algorithmes HMAC, ou la clé publique encodée PEM pour RSA et ECDSA.

Notez que la valeur `"alg"` de l’en-tête de signature est ignorée.


## <a name="jwsdecodesignature"></a>jws.decode(signature)

(Synchrone) Retourne l’en-tête décodé, la charge utile décodée et les parties de la signature JWS.

Retourne un objet avec trois propriétés, par exemple
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

Retourne un nouvel objet SignStream.

Options :

* `header` (requis)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (Facultatif) La valeur par défaut est « utf8 ».

À part `header`, toutes les options attendent une chaîne ou une mémoire tampon lorsque la valeur est connue à l’avance, ou un flux pour des raisons pratiques.
`key`/`privateKey`/`secret` peut également être un objet lors de l’utilisation d’une clé privée chiffrée. Voir la [documentation sur le chiffrement][encrypted-key-docs].

Exemple :

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

Retourne un nouvel objet VerifyStream.

Options :

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (Facultatif) La valeur par défaut est « utf8 ».

Toutes les options attendent une chaîne ou une mémoire tampon lorsque la valeur est connue à l’avance, ou un flux pour des raisons pratiques.

Exemple :

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>Classe : SignStream

`Readable Stream` qui émet un événement de données unique (la signature calculée) une fois terminé.

### <a name="event-done"></a>Événement : « done »
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

`Writable Stream` qui attend la charge utile JWS. Ne l’utilisez *pas* si vous avez passé une option `payload` au constructeur.

Exemple :

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

Un `Writable Stream`. Attend le secret JWS pour HMAC, ou la privateKey pour ECDSA et RSA. Ne l’utilisez *pas* si vous avez passé une option `secret` ou `key` au constructeur.

Exemple :

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>Classe : VerifyStream

Il s’agit d’un `Readable Stream` qui émet un événement de données unique, le résultat de la validité ou non de cette signature.

### <a name="event-done"></a>Événement : « done »
`function (valid, obj) { }`

`valid` est une valeur booléenne indiquant si la signature est valide ou non.

### <a name="verifiersignature"></a>verifier.signature

`Writable Stream` qui attend une signature JWS. Ne l’utilisez *pas* si vous avez passé une option `signature` au constructeur.

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

`Writable Stream` qui attend une clé publique ou un secret. Ne l’utilisez *pas* si vous avez passé une option `key` ou `secret` au constructeur.

# <a name="todo"></a>TODO

* Il semble qu’il faudrait qu’il y ait des API/options pratiques pour définir l’algorithme plutôt que de devoir définir un objet d’en-tête avec `{ alg: 'ES512' }` ou autre à chaque fois.

* Prise en charge de X.509, ugh

# <a name="license"></a>Licence

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
