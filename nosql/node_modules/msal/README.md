---
ms.openlocfilehash: 4f36d4681facd228c63b48050973040e9785d30f
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051225"
---

<a name="microsoft-authentication-library-for-javascript-msaljs"></a>Bibliothèque d’authentification Microsoft pour JavaScript (MSAL.js)
=========================================================

| [Prise en main](https://docs.microsoft.com/azure/active-directory/develop/guidedsetups/active-directory-javascriptspa)| [Documentation AAD](https://aka.ms/aaddevv2) | [Référence de bibliothèque](https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal.html) | [Support](README.md#community-help-and-support) | [Exemples](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Samples)
| --- | --- | --- | --- | --- |

⚠️⚠️⚠️ Cette bibliothèque ne reçoit plus de nouvelles fonctionnalités et reçoit uniquement des correctifs de sécurité et de bogues critiques. Les nouvelles applications doivent utiliser [@azure/msal-browser](https://www.npmjs.com/package/@azure/msal-browser) à la place. ⚠️⚠️⚠️

MSAL pour JavaScript permet aux applications web JavaScript côté client qui s’exécutent dans un navigateur web d’authentifier les utilisateurs à l’aide de comptes professionnels ou scolaires [Azure AD](https://docs.microsoft.com/azure/active-directory/develop/v2-overview) (AAD), de comptes personnels Microsoft (MSA) et de fournisseurs d’identité sociale tels que Facebook, Google, LinkedIn, les comptes Microsoft, etc. via le service [Azure AD B2C](https://docs.microsoft.com/azure/active-directory-b2c/active-directory-b2c-overview#identity-providers). Il permet également à votre application d’obtenir des jetons pour accéder aux services [Microsoft Cloud](https://www.microsoft.com/enterprise) comme [Microsoft Graph](https://graph.microsoft.io).

[![version npm](https://img.shields.io/npm/v/msal.svg?style=flat)](https://www.npmjs.com/package/msal)
[![version npm](https://img.shields.io/npm/dm/msal.svg)](https://nodei.co/npm/msal/)
[![codecov](https://codecov.io/gh/AzureAD/microsoft-authentication-library-for-js/branch/dev/graph/badge.svg?flag=msal-core)](https://codecov.io/gh/AzureAD/microsoft-authentication-library-for-js)

## <a name="installation"></a>Installation

### <a name="via-npm"></a>Via NPM :

    npm install msal

## <a name="via-cdn"></a>Via CDN :

<!-- CDN_LATEST -->
```html
<script type="text/javascript" src="https://alcdn.msauth.net/lib/1.4.11/js/msal.min.js"></script>
```

[Des informations complètes et des bonnes pratiques](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-core/docs/cdn.md) sur l’utilisation de CDN sont disponibles dans notre documentation.

## <a name="what-to-expect-from-this-library"></a>Ce qu’il faut attendre de cette bibliothèque
La prise en charge de MSAL sur Javascript est constituée d’une collection de bibliothèques. `msal-core` (ou simplement `msal`) est la bibliothèque principale indépendante du framework. Une fois que la bibliothèque principale 1.x+ sera stable, nous apporterons les dernières améliorations de la version 1.x à notre bibliothèque `msal-angular`.  Nous prévoyons de déprécier la prise en charge de `msal-angularjs` en raison des tendances d’utilisation du framework et de la bibliothèque qui témoignent d’une plus grande adoption d’Angular 2+ par rapport à Angular 1x. Une fois que nos bibliothèques actuelles seront conformes aux standards, nous commencerons à répondre aux nouvelles demandes de fonctionnalités avec de nouvelles plateformes comme `react` et `node.js`.

Notre objectif est de communiquer de manière optimale avec la communauté et de prendre en compte ses opinions. Nous aimerions mettre en place une planification mensuelle des versions mineures, avec des correctifs qui soient publiés aussi souvent que nécessaire.  Le niveau de communication, de planification et de précision que nous voulons obtenir est voué à évoluer.

Consultez notre [feuille de route](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki#roadmap) pour voir ce sur quoi nous travaillons et ce que nous prévoyons de faire ensuite.

## <a name="oauth-20-and-the-implicit-flow"></a>OAuth 2.0 et flux implicite

MSAL implémente le [flux d’octroi implicite](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-implicit-grant-flow) qui est défini par le protocole OAuth 2.0 et conforme à [OpenID](https://docs.microsoft.com/azure/active-directory/develop/v2-protocols-oidc).

Notre objectif est que la bibliothèque simplifie le protocole pour que vous puissiez obtenir une authentification plug-and-play. Toutefois, il est important de connaître et de comprendre le flux implicite du point de vue de la sécurité.
Le flux implicite s’exécute dans le contexte d’un navigateur web qui ne peut pas gérer les secrets client de façon sécurisée. Il est optimisé pour les applications monopages. En outre, il dispose d’un tronçon en moins entre le client et le serveur afin que les jetons soient retournés directement au navigateur. Ces aspects le rendent naturellement moins sécurisé.
Ces problèmes de sécurité sont atténués par les pratiques standard comme l’utilisation de jetons de courte durée (pour qu’aucun jeton d’actualisation ne soit retourné), par la bibliothèque qui exige un URI de redirection inscrit pour l’application, et par la bibliothèque qui vérifie la demande et la réponse à l’aide d’un paramètre unique de nonce et d’état.

## <a name="cache-storage"></a>Stockage du cache

Nous proposons deux méthodes de stockage pour MSAL : `localStorage` et `sessionStorage`.  Nous vous recommandons d’utiliser `sessionStorage` car il est davantage sécurisé pour le stockage des jetons obtenus par vos utilisateurs. Cependant, `localStorage` vous fournira l’authentification unique sur tous les onglets et sessions utilisateur.  Nous vous encourageons à explorer les options afin de prendre la meilleure décision pour votre application.

### <a name="forcerefresh-to-skip-cache"></a>forceRefresh pour ignorer le cache
Si vous souhaitez ignorer un jeton mis en cache et accéder au serveur, passez la valeur booléenne `forceRefresh` dans l’objet `AuthenticationParameters` qui est utilisé pour effectuer une demande de connexion ou de jeton. **AVERTISSEMENT :** Elle ne doit pas être utilisée par défaut en raison de l’impact sur les performances de votre application.  L’utilisation du cache donnera à vos utilisateurs une meilleure expérience. Vous ne devez ignorer le cache que si vous savez que les données actuellement mises en cache ne sont pas à jour.  Exemple : Un outil d’administration permettant d’attribuer des rôles à un utilisateur qui doit obtenir un nouveau jeton avec des rôles mis à jour.

## <a name="usage"></a>Usage
L’exemple ci-dessous vous montre comment connecter un utilisateur et acquérir un jeton à utiliser pour l’API Graph de Microsoft.

#### <a name="prerequisites"></a>Prérequis

Avant d’utiliser MSAL.js, vous devez [inscrire une application dans Azure AD](https://docs.microsoft.com/azure/active-directory/develop/quickstart-register-app) afin d’obtenir un `clientId` valide pour la configuration, et afin d’inscrire les routes sur lesquelles votre application acceptera le trafic de redirection.

#### <a name="1-instantiate-the-useragentapplication"></a>1. Instancier userAgentApplication

`UserAgentApplication` peut être configuré avec différentes options,qui sont détaillées dans notre [Wiki](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL.js-1.0.0-api-release#configuration-options). Cependant, le seul paramètre obligatoire est `auth.clientId`.

Après avoir instancié votre instance, si vous prévoyez d’utiliser un flux de redirection dans MSAL 1.2.x ou une version antérieure (`loginRedirect` et `acquireTokenRedirect`), vous devez inscrire un gestionnaire de rappel à l’aide de `handleRedirectCallback(authCallback)` où `authCallback = function(AuthError, AuthResponse)`. À compter de MSAL 1.3.0, cette option est facultative. La fonction de rappel est appelée une fois la demande d’authentification terminée, qu’elle ait réussi ou échoué. Cela n’est pas obligatoire pour les flux « popup », car ils retournent des promesses.

```JavaScript
    import * as Msal from "msal";
    // if using cdn version, 'Msal' will be available in the global scope

    const msalConfig = {
        auth: {
            clientId: 'your_client_id'
        }
    };

    const msalInstance = new Msal.UserAgentApplication(msalConfig);

    msalInstance.handleRedirectCallback((error, response) => {
        // handle redirect response or error
    });

```

Pour plus d’informations sur les options de configuration, lisez [Initialiser des applications clientes avec MSAL.js](https://docs.microsoft.com/azure/active-directory/develop/msal-js-initializing-client-applications).

#### <a name="2-login-the-user"></a>2. Connecter l’utilisateur

Votre application doit connecter l’utilisateur avec la méthode `loginPopup` ou `loginRedirect` afin d’établir le contexte utilisateur.

Lorsque les méthodes de connexion sont appelées et que l’authentification de l’utilisateur est effectuée par le service Azure AD, un [jeton d’ID](https://docs.microsoft.com/azure/active-directory/develop/id-tokens) est retourné puis utilisé pour identifier l’utilisateur avec des informations de base.

Lorsque vous connectez un utilisateur, vous pouvez passer des étendues que l’utilisateur peut préaccepter lors de la connexion. Toutefois, cela n’est pas obligatoire. Notez que l’acceptation des étendues lors de la connexion ne retourne pas d’access_token pour ces étendues. Toutefois, cela vous permet d’obtenir un jeton silencieusement avec les étendues passées, sans aucune autre interaction de l’utilisateur.

Il est recommandé de demander uniquement les étendues dont vous avez besoin, et seulement lorsque vous en avez besoin. Ce concept se nomme « consentement dynamique ». Non seulement cela crée un consentement plus interactif pour les utilisateurs de votre application, mais en plus, cela réduit le nombre d’abandons des utilisateurs qui peuvent être mal à l’aise à l’idée d’accorder une longue liste d’autorisations pour des fonctionnalités qu’ils n’utilisent pas encore.

AAD vous permet uniquement d’obtenir le consentement pour trois ressources à la fois. Toutefois, vous pouvez demander de nombreuses étendues au sein d’une même ressource.
Lorsque l’utilisateur effectue une demande de connexion, vous pouvez passer plusieurs ressources et leurs étendues correspondantes, car AAD émet un idToken qui préaccepte ces étendues. Toutefois, les appels acquireToken ne sont valides que pour une seule ressource et plusieurs étendues. Si vous avez besoin d’accéder à plusieurs ressources, effectuez des appels acquireToken distincts pour chaque ressource.

```JavaScript
   var loginRequest = {
       scopes: ["user.read", "mail.send"] // optional Array<string>
   };

    msalInstance.loginPopup(loginRequest)
        .then(response => {
            // handle response
        })
        .catch(err => {
            // handle error
        });

```

##### <a name="ssosilent"></a>ssoSilent

Si vous êtes certain que l’utilisateur dispose d’une session existante et que vous souhaitez établir un contexte utilisateur sans demander d’interaction, vous pouvez appeler `ssoSilent` avec un `loginHint` ou un `sid` (disponible en tant que [revendication facultative](https://docs.microsoft.com/azure/active-directory/develop/active-directory-optional-claims)). MSAL tentera alors d’effectuer silencieusement une authentification unique dans la session existante et d’établir le contexte utilisateur.

Notez que s’il n’y a pas de session active pour le `loginHint` ou `sid` donné, une erreur sera levée et devra être gérée en appelant une méthode de connexion interactive (`loginPopup` ou `loginRedirect`).

Exemple :

```js
const ssoRequest = {
    loginHint: "user@example.com"
};

msalInstance.ssoSilent(ssoRequest)
    .then(response => {
        // session silently established
    })
    .catch(error => {
        // handle error by invoking an interactive login method
        msalInstance.loginPopup(ssoRequest);
    });
```

#### <a name="3-get-an-access-token-to-call-an-api"></a>3. Obtenir un jeton d’accès pour appeler une API

Dans MSAL, vous pouvez obtenir des jetons d’accès pour les API que votre application doit appeler à l’aide de la méthode `acquireTokenSilent`, qui envoie une demande silencieuse (sans inviter l’utilisateur via l’interface utilisateur) à Azure AD pour obtenir un jeton d’accès. Le service Azure AD retourne ensuite un [jeton d’accès](https://docs.microsoft.com/azure/active-directory/develop/access-tokens) contenant les étendues acceptées par l’utilisateur pour permettre à votre application d’appeler l’API de façon sécurisée.

Vous pouvez utiliser `acquireTokenRedirect` ou `acquireTokenPopup` pour envoyer des demandes interactives. Cependant, il est recommandé de n’afficher des expériences interactives que si vous ne parvenez pas à obtenir un jeton silencieusement, en raison d’erreurs dues à la nécessité d’une interaction. Si vous utilisez un appel de jeton interactif, celui-ci doit correspondre à la méthode de connexion utilisée dans votre application. (`loginPopup`=> `acquireTokenPopup`, `loginRedirect` => `acquireTokenRedirect`).

Si l’appel `acquireTokenSilent` échoue avec une erreur de type `InteractionRequiredAuthError`, vous devez lancer une demande interactive.  Cela peut se produire pour de nombreuses raisons, notamment si les étendues ont été révoquées, les jetons ont expiré ou les mots de passe ont été modifiés.

`acquireTokenSilent` recherche un jeton valide dans le cache et, si celui-ci est proche de l’expiration ou n’existe pas, il tente automatiquement de l’actualiser.

Pour plus d’informations, consultez [Types de données des demandes et des réponses](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL.js-1.0.0-api-release#signing-in-and-getting-tokens-with-msaljs).

```JavaScript
    // if the user is already logged in you can acquire a token
    if (msalInstance.getAccount()) {
        var tokenRequest = {
            scopes: ["user.read", "mail.send"]
        };
        msalInstance.acquireTokenSilent(tokenRequest)
            .then(response => {
                // get access token from response
                // response.accessToken
            })
            .catch(err => {
                // could also check if err instance of InteractionRequiredAuthError if you can import the class.
                if (err.name === "InteractionRequiredAuthError") {
                    return msalInstance.acquireTokenPopup(tokenRequest)
                        .then(response => {
                            // get access token from response
                            // response.accessToken
                        })
                        .catch(err => {
                            // handle error
                        });
                }
            });
    } else {
        // user is not logged in, you will need to log them in to acquire a token
    }
```

#### <a name="4-use-the-token-as-a-bearer-in-an-http-request-to-call-the-microsoft-graph-or-a-web-api"></a>4. Utiliser le jeton comme un porteur dans une requête HTTP pour appeler Microsoft Graph ou une API web

```JavaScript
    var headers = new Headers();
    var bearer = "Bearer " + token;
    headers.append("Authorization", bearer);
    var options = {
         method: "GET",
         headers: headers
    };
    var graphEndpoint = "https://graph.microsoft.com/v1.0/me";

    fetch(graphEndpoint, options)
        .then(resp => {
             //do something with response
        });
```

Pour en savoir plus sur les fonctionnalités MSAL.js, consultez le [Wiki MSAL](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki) et explorez des [exemples de code](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Samples) complets.

## <a name="security-reporting"></a>Création de rapports sur la sécurité

Si vous rencontrez un problème de sécurité avec nos bibliothèques ou services, signalez-le nous à l’adresse [secure@microsoft.com](mailto:secure@microsoft.com), en fournissant autant de détails que possible. Votre envoi peut être éligible à une prime par le biais du programme [Microsoft Bounty](http://aka.ms/bugbounty). Nous vous demandons de ne pas signaler de problèmes de sécurité dans GitHub Issues ou tout autre site public. Nous vous contacterons rapidement après réception des informations. Nous vous encourageons à activer les notifications d’incidents de sécurité en vous rendant sur [cette page](https://technet.microsoft.com/security/dd252948) et en vous abonnant aux alertes d’avis de sécurité.

## <a name="license"></a>Licence

Copyright (c) Microsoft Corporation.  Tous droits réservés. Concédé sous licence MIT (ladite « Licence ») ;

## <a name="we-value-and-adhere-to-the-microsoft-open-source-code-of-conduct"></a>Nous apprécions et respectons le code de conduite Microsoft Open Source

Ce projet a adopté le [Code de conduite Open Source de Microsoft](https://opensource.microsoft.com/codeofconduct/). Pour plus d’informations, consultez le [Forum Aux Questions sur le Code de conduite](https://opensource.microsoft.com/codeofconduct/faq/) ou contactez [opencode@microsoft.com](mailto:opencode@microsoft.com) si vous avez d’autres questions ou des commentaires.
