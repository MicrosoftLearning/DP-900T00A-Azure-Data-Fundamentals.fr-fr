---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051206"
---
# <a name="tools"></a>Outils

## <a name="clang-format"></a>clang-format

Les outils de vérification clang-format sont conçus pour vérifier les lignes de code modifiées par rapport aux git-refs donnés.

## <a name="migration-script"></a>Script de migration

L’outil de migration est conçu pour réduire le nombre de tâches répétitives au cours du processus de migration. Toutefois, le script n’a pas pour objectif de tout convertir à votre place. Certains petits correctifs et une reconstruction majeure sont généralement nécessaires.

### <a name="how-to-use"></a>Utilisation

Pour exécuter le script de conversion, vérifiez d’abord que vous disposez de la dernière version de `node-addon-api` dans votre répertoire `node_modules`.
```
npm install node-addon-api
```

Exécutez ensuite le script qui passe votre répertoire de projet
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

Une fois l’exécution terminée, recompilez et déboguez les problèmes qui n’ont pas été détectés par le script.


### <a name="quick-fixes"></a>Correctifs rapides
Voici la liste des choses qui peuvent être corrigées facilement.
  1. Remplacez la valeur de retour de votre méthode par « void » si elle ne retourne pas de valeur à JavaScript.
  2. Utilisez `.` pour accéder à l’attribut ou pour appeler la fonction membre dans Napi::Object au lieu de `->`.
  3. `Napi::New(env, value);` de `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>Reconstructions majeures
L’implémentation de `Napi::ObjectWrap` est très différente de celle de NAN. `Napi::ObjectWrap` accepte un pointeur vers l’objet wrappé et crée une référence à l’objet wrappé à l’intérieur du constructeur ObjectWrap. `Napi::ObjectWrap` associe également les méthodes d’instance de l’objet wrappé au module Javascript au lieu des méthodes statiques comme le fait NAN.

Par conséquent, si vous utilisez Nan::ObjectWrap dans votre module, vous devez effectuer les étapes suivantes.

  1. Convertissez votre fonction [ClassName]::New en fonction constructeur qui accepte un `Napi::CallbackInfo`. Déclarez-la comme
```
[ClassName](const Napi::CallbackInfo& info);
```
et définissez-la comme
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
De cette façon, le constructeur `Napi::ObjectWrap` est appelé une fois l’objet instancié, et `Napi::ObjectWrap` peut utiliser le pointeur `this` pour créer une référence à l’objet wrappé.

  2. Déplacez le code du constructeur d’origine vers le nouveau constructeur. Supprimez le constructeur d’origine.
  3. Dans votre fonction d’initialisation de classe, associez des méthodes natives de la façon suivante.
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. Dans la fonction où vous devez exécuter une opération Unwrap pour l’objet ObjectWrap dans NAN comme `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`, utilisez le pointeur `this` directement comme l’objet déwrappé, car chaque instance ObjectWrap est associée à une instance d’objet unique.


Si vous trouvez toujours des problèmes après avoir suivi ce guide, envoyez-nous une description du problème pour que nous tentions de le résoudre.
