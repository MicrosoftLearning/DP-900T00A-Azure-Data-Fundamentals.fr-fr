---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051801"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![Badge de la version][2]][1]</sup>

[![État de build][3]][4]
[![État de dépendance][5]][6]
[![État de dépendance dev][7]][8]
[![Licence][license-image]][license-url]
[![Téléchargements][downloads-image]][downloads-url]

[![badge npm][11]][1]

Bibliothèque permettant d’analyser et de stringifier les chaînes de requête avec une sécurité supplémentaire.

Gestionnaire principal : [Jordan Harband](https://github.com/ljharb)

Le module **qs** a été créé par [TJ Holowaychuk](https://github.com/visionmedia/node-querystring), qui est également chargé de sa gestion.

## <a name="usage"></a>Usage

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>Analyse des objets

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** vous permet de créer des objets imbriqués dans vos chaînes de requête, en incluant le nom des sous-clés entre crochets `[]`.
Par exemple, la chaîne `'foo[bar]=baz'` est convertie en :

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

Lorsque vous utilisez l’option `plainObjects`, la valeur analysée est retournée en tant qu’objet Null créé via `Object.create(null)`. Par conséquent, celui-ci ne contiendra pas de méthodes prototypes, et les utilisateurs pourront définir ces noms sur la valeur de leur choix :

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

Par défaut, les paramètres susceptibles de substituer les propriétés du prototype d’objet sont ignorés. Si vous souhaitez conserver les données de ces champs, utilisez `plainObjects` comme mentionné ci-dessus, ou définissez `allowPrototypes` sur `true` pour autoriser les entrées utilisateur à substituer ces propriétés. *AVERTISSEMENT* En général, il est déconseillé d’activer cette option, car elle peut causer des problèmes si vous tentez d’utiliser des propriétés qui ont été substituées. Soyez toujours prudent avec cette option.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

Les chaînes codées par l’URI fonctionnent également :

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

Vous pouvez également imbriquer vos objets, comme ici `'foo[bar][baz]=foobarbaz'` :

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

Par défaut, l’imbrication d’objets **qs** arrête l’analyse à 5 enfants. Cela signifie que si vous tentez d’analyser une chaîne comme `'a[b][c][d][e][f][g][h][i]=j'`, l’objet résultant sera :

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

Cette profondeur d’analyse peut être substituée en passant une option `depth` à `qs.parse(string, [options])` :

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

La limite de profondeur permet d’éviter les abus lorsque **qs** est utilisé pour analyser les entrées utilisateur. La valeur de profondeur doit rester peut élevée.

Pour des raisons similaires, par défaut **, qs** analyse 1 000 paramètres au maximum. Cette valeur peut être substituée en passant une option `parameterLimit` :

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

Pour contourner le point d’interrogation de début, utilisez `ignoreQueryPrefix` :

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

Vous pouvez également passer un délimiteur facultatif :

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

Les délimiteurs peuvent également être des expressions régulières :

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

L’option `allowDots` peut être utilisée pour activer la notation point :

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

Si vous devez gérer des navigateurs ou des services hérités, vous pouvez également décoder des octets avec encodage-pourcent au format iso-8859-1 :

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

Certains services ajoutent une valeur initiale de `utf8=✓` aux formulaires afin que les anciennes versions d’Internet Explorer soient plus susceptibles d’envoyer le formulaire au format utf-8. En outre, le serveur peut vérifier la valeur par rapport aux encodages incorrects du caractère de coche, et détecter qu’une chaîne de requête ou le corps de `application/x-www-form-urlencoded` *n’ont pas* été envoyés au format utf-8, par exemple si le formulaire avait un paramètre `accept-charset` ou si la page contenante avait un jeu de caractères différent.

**qs** prend en charge ce mécanisme via l’option `charsetSentinel`.
S’il est spécifié, le paramètre `utf8` est omis de l’objet retourné. Il sera utilisé pour basculer vers le mode `iso-8859-1`/`utf-8`, en fonction de la façon dont la coche est encodée.

**Important** : Lorsque vous spécifiez à la fois l’option `charset` et l’option `charsetSentinel`, `charset` est remplacée si la requête contient un paramètre `utf8` à partir duquel l’ensemble de caractères peut être déduit. Dans ce sens, `charset` se comportera comme l’ensemble de caractères par défaut plutôt que comme l’ensemble de caractères faisant autorité.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

Si vous souhaitez décoder la syntaxe `&#...;` pour obtenir le caractère réel, vous pouvez également spécifier l’option `interpretNumericEntities` :

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

Cela fonctionne également lorsque l’ensemble de caractères a été détecté en mode `charsetSentinel`.

### <a name="parsing-arrays"></a>Analyse des tableaux

**qs** peut également analyser des tableaux à l’aide d’une notation `[]` similaire :

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

Vous pouvez également spécifier un index :

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

La seule chose qui différencie l’index d’un tableau de la clé d’un objet est que la valeur entre crochets doit être un nombre si vous voulez créer un tableau. Lorsque vous créez des tableaux avec certains index, **qs** compacte une matrice creuse uniquement avec les valeurs existantes en conservant leur ordre :

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

Vous pouvez également utiliser l’option `allowSparse` pour analyser les matrices creuses :

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

Notez qu’une chaîne vide est également une valeur et qu’elle sera conservée :

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** limite également la spécification d’index dans un tableau (`20` au maximum). Tous les membres du tableau ayant un index supérieur à `20` seront convertis en un objet ayant l’index comme clé. Ceci est nécessaire si, par exemple, quelqu’un a envoyé `a[999999999]` et que l’itération de cet énorme tableau sera très longue.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

Cette limite peut être substituée en passant une option `arrayLimit` :

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

Pour désactiver entièrement l’analyse de tableau, définissez `parseArrays` sur `false`.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

Si vous mélangez des notations, **qs** fusionnera les deux éléments dans un objet :

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

Vous pouvez également créer des tableaux d’objets :

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

Certaines personnes utilisent des virgules pour joindre un tableau.**qs** peut l’analyser :
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(_cela ne peut pas convertir les objets imbriqués comme `a={b:1},{c:d}`_ )

### <a name="stringifying"></a>Stringification

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

Lors d’une stringification, **qs** encode par défaut la sortie de l’URI. Les objets sont stringifiés comme prévu :

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

Cet encodage peut être désactivé en définissant l’option `encode` sur `false` :

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

L’encodage peut être désactivé pour les clés en définissant l’option `encodeValuesOnly` sur `true` :
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

Cet encodage peut également être remplacé par une méthode d’encodage personnalisée définie comme l’option `encoder` :

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(Remarque : L’option `encoder` ne s’applique pas si `encode` est `false`)_

Similaire à l’option `encoder`, l’option `decoder` de `parse` permet de substituer le décodage des propriétés et des valeurs :

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

Vous pouvez encoder des clés et des valeurs à l’aide d’une logique différente avec l’argument de type fourni à l’encodeur :

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

L’argument de type est également fourni au décodeur :

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

Pour des raisons de clarté, nous montrerons des exemples comme si la sortie n’était pas encodée par l’URI. Dans ce cas, notez que les valeurs retournées *seront* encodées par l’URI pendant l’utilisation.

Lorsque les tableaux sont stringifiés, ils reçoivent par défaut des index explicites :

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

Vous pouvez substituer cela en définissant l’option `indices` sur `false` :

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

Vous pouvez utiliser l’option `arrayFormat` pour spécifier le format du tableau de sortie :

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

Lorsque les objets sont stringifiés, par défaut, ils utilisent la notation entre crochets :

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

Vous pouvez substituer cela pour utiliser la notation point en définissant l’option `allowDots` sur `true` :

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

Les chaînes vides et les valeurs Null omettent la valeur, mais le signe égal (=) reste en place :

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

Une clé sans valeurs (par exemple, un objet ou un tableau vide) ne retourne rien :

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

Les propriétés qui sont définies sur `undefined` seront intégralement omises :

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

La chaîne de requête peut être précédée d’un point d’interrogation :

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

Le délimiteur peut également être substitué par la stringification :

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

Si vous souhaitez uniquement substituer la sérialisation des objets `Date`, vous pouvez fournir une option `serializeDate` :

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

Vous pouvez utiliser l’option `sort` pour affecter l’ordre des clés de paramètre :

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

Enfin, vous pouvez utiliser l’option `filter` pour restreindre les clés à inclure dans la sortie stringifiée.
Si vous passez une fonction, celle-ci sera appelée pour chaque clé afin d’obtenir la valeur de remplacement. Sinon, si vous passez un tableau, celui-ci sera utilisé pour sélectionner les propriétés et les index de tableau en vue de la stringification :

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>Gestion des valeurs `null`

Par défaut, les valeurs `null` sont traitées comme des chaînes vides :

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

L’analyse ne fait pas la distinction entre les paramètres avec et sans signe égal. Les deux sont convertis en chaînes vides.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

Pour distinguer les valeurs `null` des chaînes vides, utilisez l’indicateur `strictNullHandling`. Dans la chaîne de résultat, les valeurs `null` n’ont pas de signe `=` :

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

Pour analyser les valeurs sans `=` vers `null`, utilisez l’indicateur `strictNullHandling` :

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

Pour ignorer complètement les clés de rendu avec des valeurs `null`, utilisez l’indicateur `skipNulls` :

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

Si vous communiquez avec des systèmes hérités, vous pouvez basculer vers `iso-8859-1` à l’aide de l’option `charset` :

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

Les caractères qui n’existent pas dans `iso-8859-1` seront convertis en entités numériques, un peu comme le font les navigateurs :

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

Vous pouvez utiliser l’option `charsetSentinel` pour annoncer le caractère en incluant un paramètre `utf8=✓` avec l’encodage approprié, un peu comme ce que Ruby on Rails et d’autres font lors de l’envoi de formulaires.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>Gestion des jeux de caractères spéciaux

Par défaut, l’encodage et le décodage de caractères sont effectués dans `utf-8`, et la prise en charge `iso-8859-1` est également intégrée via le paramètre `charset`.

Si vous souhaitez encoder des chaînes de requête vers un jeu de caractères différent (par exemple, [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS)), vous pouvez utiliser la bibliothèque [`qs-iconv`](https://github.com/martinheidegger/qs-iconv) :

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

Cela fonctionne également pour décoder les chaînes de requête :

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>Encodage d’espace RFC 3986 et RFC 1738

RFC3986 est utilisé comme option par défaut, et encode ' ' au format  *%20* qui offre une compatibilité descendante.
En même temps, la sortie peut être stringifiée conformément à RFC1738, avec ' ' égal à '+'.

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>Sécurité

Veuillez envoyer un e-mail à [@ljharb](https://github.com/ljharb) ou consulter https://tidelift.com/security si vous avez une vulnérabilité de sécurité potentielle à signaler.

## <a name="qs-for-enterprise"></a>qs pour l’entreprise

Disponible dans le cadre de l’abonnement Tidelift

Les personnes qui sont chargées de la gestion de qs et des milliers d’autres packages utilisent Tidelift dans le but de fournir une prise en charge et une maintenance commerciales des dépendances open source que vous utilisez pour créer vos applications. Gagnez du temps, réduisez les risques et améliorez l’intégrité du code, tout en payant les gestionnaires uniquement pour les dépendances que vous utilisez. [En savoir plus.](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
