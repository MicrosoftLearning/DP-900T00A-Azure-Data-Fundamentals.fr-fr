---
ms.openlocfilehash: 496981207a34eb019688e8f2583ccc1abcbb5bce
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050437"
---
<a name="semver1----the-semantic-versioner-for-npm"></a>semver(1) -- Le versioner sémantique pour npm
===========================================

## <a name="install"></a>Installer

```bash
npm install --save semver
````

## <a name="usage"></a>Usage

En tant que module de nœud :

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

En tant qu’utilitaire en ligne de commande :

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## <a name="versions"></a>Versions

Une « version » est décrite par la spécification `v2.0.0` située ici : <https://semver.org/>.

Un caractère de début `"="` ou `"v"` est supprimé et ignoré.

## <a name="ranges"></a>Plages

Un `version range` est un ensemble de `comparators` qui spécifient des versions qui satisfont la plage.

Un `comparator` se compose d’un `operator` et d’un `version`.  L’ensemble de `operators` primitifs est :

* `<` Inférieur à
* `<=` Inférieur ou égal à
* `>` Supérieur à
* `>=` Supérieur ou égal à
* `=` Égal à.  Si aucun opérateur n’est spécifié, l’égalité est supposée. Cet opérateur est donc facultatif, mais PEUT être inclus.

Par exemple, le comparateur `>=1.2.7` peut correspondre aux versions `1.2.7`, `1.2.8`, `2.5.3`et `1.3.9`, mais pas aux versions `1.2.6` ou `1.1.0`.

Les comparateurs peuvent être joints par des espaces blancs pour former un `comparator set`, qui est satisfait par l’**intersection** de tous les comparateurs qu’il inclut.

Une plage est composée d’un ou de plusieurs ensembles de comparateurs, joints par `||`.  Une version correspond à une plage si, et seulement si, chaque comparateur d’au moins un des ensembles de comparateurs séparés par des `||` est satisfait par la version.

Par exemple, la plage `>=1.2.7 <1.3.0` peut correspondre aux versions `1.2.7`, `1.2.8` et `1.2.99`, mais pas aux versions `1.2.6`, `1.3.0` ou `1.1.0`.

La plage `1.2.7 || >=1.2.9 <2.0.0` peut correspondre aux versions `1.2.7`, `1.2.9` et `1.4.6`, mais pas aux versions `1.2.8` ou `2.0.0`.

### <a name="prerelease-tags"></a>Étiquettes de préversion

Si une version a une étiquette de préversion (par exemple, `1.2.3-alpha.3`), elle ne sera autorisée à satisfaire les ensembles de comparateurs que si au moins un comparateur avec le même tuple `[major, minor, patch]` a également une étiquette de préversion.

Par exemple, la plage `>1.2.3-alpha.3` serait autorisée à correspondre à la version `1.2.3-alpha.7`, mais elle *ne serait pas* satisfaite par `3.4.5-alpha.9`, même si `3.4.5-alpha.9` est techniquement « supérieure à » `1.2.3-alpha.3` selon les règles de tri SemVer.  La plage de versions accepte uniquement les étiquettes de préversion sur la version `1.2.3`.  La version `3.4.5` *satisferait* la plage, car elle n’a pas d’indicateur de préversion et parce que `3.4.5` est supérieure à `1.2.3-alpha.7`.

L’objectif de ce comportement est double.  Tout d’abord, les préversions sont souvent mises à jour très rapidement et contiennent de nombreux changements cassants qui ne sont pas encore prêts pour la consommation publique (par conception).
Par conséquent, par défaut, elles sont exclues de la sémantique de correspondance de plage.

Deuxièmement, un utilisateur qui a choisi d’utiliser une préversion a clairement indiqué son intention d’utiliser *cet ensemble spécifique* de versions alpha/beta/rc.  En incluant une étiquette de préversion dans la plage, l’utilisateur indique qu’il est conscient du risque.  Toutefois, il n’est toujours pas bon de supposer qu’il choisira de prendre un risque similaire sur l’ensemble de préversions *suivant*.

Notez que ce comportement peut être supprimé (en traitant toutes les préversions comme si elles étaient des versions normales, à des fins de correspondance de plage) en définissant l’indicateur `includePrerelease` de l’objet options sur toutes les [fonctions](https://github.com/npm/node-semver#functions) qui effectuent une correspondance de plage.

#### <a name="prerelease-identifiers"></a>Identificateurs de préversion

La méthode `.inc` accepte un argument de chaîne `identifier` supplémentaire qui ajoute la valeur de la chaîne en tant qu’identificateur de préversion :

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

Exemple de ligne de commande :

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

Qui peut ensuite être utilisé pour incrémenter encore davantage :

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

### <a name="advanced-range-syntax"></a>Syntaxe de plage avancée

La syntaxe de plage avancée « désugare » pour obtenir des comparateurs primitifs de manière déterministe.

Les plages avancées peuvent être combinées de la même façon que les comparateurs primitifs à l’aide d’espaces blancs ou de `||`.

#### <a name="hyphen-ranges-xyz---abc"></a>Plages de traits d’union `X.Y.Z - A.B.C`

Spécifie un ensemble inclusif.

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

Si une version partielle est fournie comme première version de la plage inclusive, les éléments manquants sont remplacés par des zéros.

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

Si une version partielle est fournie comme la deuxième version de la plage inclusive, toutes les versions qui commencent par les parties fournies du tuple sont acceptées, mais rien qui serait supérieur aux parties de tuple fournies.

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0`

#### <a name="x-ranges-12x-1x-12-"></a>Plages X `1.2.x` `1.X` `1.2.*` `*`

`X`, `x` ou `*` peuvent être utilisés en remplacement de l’une des valeurs numériques du tuple `[major, minor, patch]`.

* `*` := `>=0.0.0` (N’importe quelle version est satisfaisante)
* `1.x` := `>=1.0.0 <2.0.0` (correspondant à la version principale)
* `1.2.x` := `>=1.2.0 <1.3.0` (correspondant aux versions majeure et mineure)

Une plage de versions partielles est traitée comme une plage X, de sorte que le caractère spécial est facultatif.

* `""` (chaîne vide) := `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`

#### <a name="tilde-ranges-123-12-1"></a>Plages de tilde `~1.2.3` `~1.2` `~1`

Autorise les modifications au niveau du correctif si une version mineure est spécifiée dans le comparateur.  Autorise les modifications au niveau de la version mineure si ce n’est pas le cas.

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0` (Identique à `1.2.x`)
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0` (Identique à `1.x`)
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0` (Identique à `0.2.x`)
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0` (Identique à `0.x`)
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` Notez que les préversions de la version `1.2.3` sont autorisées, si elles sont supérieures ou égales à `beta.2`.  `1.2.3-beta.4` serait donc autorisé, mais pas `1.2.4-beta.2`, car il s’agit d’une préversion d’un tuple `[major, minor, patch]` différent.

#### <a name="caret-ranges-123-025-004"></a>Plages de caret `^1.2.3``^0.2.5``^0.0.4`

Autorise les modifications qui ne modifient pas le chiffre différent de zéro situé le plus à gauche dans le tuple `[major, minor, patch]`.  En d’autres termes, cela autorise les mises à jour correctives et mineures pour les versions `1.0.0` et supérieures, les mises à jour correctives pour les versions `0.X >=0.1.0`, mais *aucune* mise à jour pour les versions `0.0.X`.

De nombreux auteurs traitent une version `0.x` comme si `x` était le principal indicateur de changement cassant.

Les plages de caret sont idéales lorsqu’un auteur est susceptible d’apporter des changements cassants entre les versions `0.2.4` et `0.3.0`, ce qui est une pratique courante.
Toutefois, cela suppose qu’*il n’y aura pas* de changements cassants entre `0.2.4` et `0.2.5`.  Cela permet d’apporter des modifications présumées additionnelles (mais non cassantes), d’après les pratiques couramment observées.

* `^1.2.3` := `>=1.2.3 <2.0.0`
* `^0.2.3` := `>=0.2.3 <0.3.0`
* `^0.0.3` := `>=0.0.3 <0.0.4`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` Notez que les préversions de la version `1.2.3` sont autorisées, si elles sont supérieures ou égales à `beta.2`.  `1.2.3-beta.4` serait donc autorisé, mais pas `1.2.4-beta.2`, car il s’agit d’une préversion d’un tuple `[major, minor, patch]` différent.
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4` Notez que les préversions de la version `0.0.3` *uniquement* sont autorisées, si elles sont supérieures ou égales à `beta`.  `0.0.3-pr.2` serait donc autorisé.

Lors de l’analyse des plages de caret, une valeur `patch` manquante « désugare » vers le nombre `0`. Toutefois, cela permet une flexibilité au sein de cette valeur, même si les versions principales et mineures sont toutes les deux `0`.

* `^1.2.x` := `>=1.2.0 <2.0.0`
* `^0.0.x` := `>=0.0.0 <0.1.0`
* `^0.0` := `>=0.0.0 <0.1.0`

Des valeurs `minor` et `patch` manquantes auront pour effet de « désugarer » à zéro. Toutefois, cela permettra une certaine flexibilité au sein de ces valeurs, même si la version principale est égale à zéro.

* `^1.x` := `>=1.0.0 <2.0.0`
* `^0.x` := `>=0.0.0 <1.0.0`

### <a name="range-grammar"></a>Grammaire des plages

Voici une grammaire Backus-Naur pour les plages, destinée aux auteurs d’analyseurs :

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## <a name="functions"></a>Fonctions

Toutes les méthodes et classes prennent un argument d’objet final `options`.  Toutes les options de cet objet sont `false` par défaut.  Les options prises en charge sont :

- `loose` Soyez plus indulgents concernant les chaînes semver qui ne sont pas tout à fait valides.
  (Toutes les sorties résultantes seront bien sûr strictement conformes à 100 %.)  Pour des raisons de compatibilité descendante, si l’argument `options` est une valeur booléenne et non un objet, il sera interprété comme le paramètre `loose`.
- `includePrerelease`  À définir pour supprimer le [comportement par défaut](https://github.com/npm/node-semver#prerelease-tags) qui consiste à exclure des plages les versions étiquetées comme des préversions, sauf si elles sont explicitement choisies.

Les comparateurs et les plages en mode strict seront stricts sur les chaînes SemVer qu’ils analysent.

* `valid(v)` : Retourne la version analysée ou une valeur Null si elle n’est pas valide.
* `inc(v, release)` : Retourne la version incrémentée par le type de version (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` ou `prerelease`) ou une valeur Null si elle n’est pas valide
  * `premajor` dans un appel fera passer la version vers la version principale suivante et vers une préversion de cette version principale.
    `preminor` et `prepatch` fonctionnent de la même façon.
  * Si elle est appelée à partir d’une version qui n’est pas une préversion, `prerelease` fonctionnera de la même façon que `prepatch`. Cela incrémente la version du correctif, puis crée une préversion. Si la version entrée est déjà une préversion, cela ne fera que l’incrémenter.
* `prerelease(v)` : Retourne un tableau de composants de préversion, ou une valeur Null s’il n’en existe aucun. Exemple : `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)` : Retourne le numéro de la version principale.
* `minor(v)` : Retourne le numéro de la version mineure.
* `patch(v)` : Retourne le numéro de version du correctif.
* `intersects(r1, r2, loose)` : Retourne true si les deux plages ou comparateurs fournis se croisent.
* `parse(v)` : Essayez d’analyser une chaîne en tant que version sémantique, en retournant soit un objet `SemVer`, soit `null`.

### <a name="comparison"></a>Comparaison

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)` : `v1 == v2` Ceci est vrai s’ils sont logiquement équivalents, même s’il ne s’agit pas exactement de la même chaîne.  Vous savez déjà comment comparer des chaînes.
* `neq(v1, v2)` : `v1 != v2` L’opposé de `eq`.
* `cmp(v1, comparator, v2)` : Passez une chaîne de comparaison pour que cela appelle la fonction correspondante ci-dessus.  `"==="` et `"!=="` effectuent une simple comparaison de chaînes, mais elles sont incluses à des fins d’exhaustivité.  Est levée si une chaîne de comparaison non valide est fournie.
* `compare(v1, v2)` : Retourne `0` si `v1 == v2` (ou `1` si `v1` est supérieure, ou `-1` si `v2` est supérieure).  Trie dans l’ordre croissant s’il est passé à `Array.sort()`.
* `rcompare(v1, v2)` : Inverse de la comparaison.  Trie un tableau de versions dans l’ordre décroissant s’il est passé à `Array.sort()`.
* `diff(v1, v2)` : Retourne la différence entre deux versions par type de version (`major`, `premajor`, `minor``preminor`, `patch`, `prepatch` ou `prerelease`), ou une valeur Null si les versions sont identiques.

### <a name="comparators"></a>Comparateurs

* `intersects(comparator)` : Retourne true si les comparateurs se croisent

### <a name="ranges"></a>Plages

* `validRange(range)` : Retourne la plage valide ou une valeur Null si elle n’est pas valide
* `satisfies(version, range)` : Retourne la valeur true si la version satisfait la plage.
* `maxSatisfying(versions, range)` : Retourne la version la plus élevée de la liste qui satisfait la plage, ou `null` si aucune d’entre elles n’est satisfaisante.
* `minSatisfying(versions, range)` : Retourne la version la plus élevée de la liste qui satisfait la plage, ou `null` si aucune d’entre elles n’est satisfaisante.
* `minVersion(range)` : Retourne la version la plus basse qui peut éventuellement correspondre à la plage donnée.
* `gtr(version, range)` : Retourne `true` si la version est supérieure à toutes les versions possibles de la plage.
* `ltr(version, range)` : Retourne `true` si la version est inférieure à toutes les versions possibles de la plage.
* `outside(version, range, hilo)` : Retourne true si la version est en dehors des limites de la plage dans la direction élevée ou basse.  L’argument `hilo` doit correspondre à la chaîne `'>'` ou `'<'`.  (Il s’agit de la fonction appelée par `gtr` et `ltr`.)
* `intersects(range)` : Retourne true si des comparateurs de plages se croisent

Étant donné que les plages peuvent ne pas être contiguës, une version peut ne pas être supérieure à une plage, ne pas être inférieure à une plage *ou* satisfaire une plage !  Par exemple, la plage `1.2 <1.2.9 || >2.0.0` peut comporter un vide entre `1.2.9` et `2.0.0`. Dans ce cas, la version `1.2.10` ne sera pas supérieure à la plage (car `2.0.1`, qui est supérieure, est satisfaisante), ni inférieure à la plage (car `1.2.8`, qui est inférieure, est satisfaisante), et elle ne satisfera pas non plus la plage.

Pour savoir si une version satisfait ou non une plage, utilisez la fonction `satisfies(version, range)`.

### <a name="coercion"></a>Forçage de type

* `coerce(version)` : Force le type d’une chaîne vers semver si possible

Cela vise à fournir une traduction très approximative d’une chaîne non semver en chaîne semver. Cela recherche le premier chiffre d’une chaîne et consomme tous les caractères restants qui répondent au moins à un semver partiel (par exemple, `1`, `1.2`, `1.2.3`) jusqu’à la longueur maximale autorisée de 256 caractères.  Les versions plus longues sont simplement tronquées (`4.6.3.9.2-alpha2` devient `4.6.3`).  Tout le texte environnant est simplement ignoré (`v3.4 replaces v3.3.1` devient `3.4.0`).  Le forçage de type échouera uniquement pour le texte auquel il manque des chiffres (`version one` n’est pas valide).  La longueur maximale de n’importe quel composant semver envisagé pour le forçage de type est de 16 caractères. Les composants plus longs seront ignorés (`10000000000000000.4.7.4` devient `4.7.4`).  La valeur maximale de n’importe quel composant semver est de `Number.MAX_SAFE_INTEGER || (2**53 - 1)`. Les composants de valeur supérieure ne sont pas valides (`9999999999999999.4.7.4` est probablement non valide).
