---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051585"
---
# <a name="stoppable"></a>Stoppable

[![État de la build](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> Le `server.close()` de Node est vraisemblablement le [comportement par défaut attendu](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Résumé

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Stoppable cesse d’accepter les nouvelles connexions et ferme les connexions inactives existantes (y compris les connexions toujours actives) sans tuer les demandes en cours.

## <a name="requirements"></a>Spécifications

- Node.js v6+

Node.js v4.x est *non officiellement* pris en charge.

## <a name="installation"></a>Installation

```bash
yarn add stoppable
```

(ou utilisez npm)

## <a name="usage"></a>Usage

**constructor**

```js
stoppable(server, grace)
```

Décore l’instance de serveur avec une méthode `stop`.
Retourne l’instance de serveur, peut donc être chaînée ou exécutée comme instruction autonome.

- server : Toute instance de serveur HTTP ou HTTPS
- grace : Temps d’attente en millisecondes avant la fermeture forcée des connexions

`grace` est défini par défaut sur Infinity (pas de fermeture forcée).
Si vous voulez tuer immédiatement tous les sockets, vous pouvez utiliser une période de grâce de 0.

**stop()**

```js
server.stop(callback)
```

Ferme le serveur.

- callback : transmis à la fonction existante `server.close` pour inscrire automatiquement un événement « close ».
Le premier argument est une erreur et le deuxième est une valeur booléenne qui indique s’il s’est arrêté normalement.

## <a name="design-decisions"></a>Choix de conception

- L’application d’un « monkey-patch » n’est généralement pas la solution idéale, mais dans ce cas c’est la meilleure API. Disons qu’elle est « décorative ».
- `grace` peut être spécifié sur `stop`, mais il est préférable de s’aligner sur l’API existante `server.close`.
- Les clients doivent être traités avec respect, donc nous ne faisons pas que détruire les sockets, nous envoyons d’abord des paquets `FIN`.
- Toute solution à ce problème nécessite de tenir compte de chaque connexion et demande/réponse.
Nous effectuons un minimum de travail sur ces chemins de code « chauds » et retardons autant que possible la méthode réelle `stop`.

## <a name="performance"></a>Performances

Il n’existe aucun moyen de fournir cette fonctionnalité sans tenir compte de la connexion, la déconnexion, la demande et la réponse.
Toutefois, Stoppable s’efforce de faire un travail minimal dans les chemins de code chauds et d’utiliser des structures de données optimales.

Je serais intéressé de voir des benchmarks sur les performances réelles. Le simple benchmark sur l’artillerie du bouclage inclus dans la bibliothèque montre très peu de surcharge avec l’utilisation d’un serveur pouvant être arrêté :

### <a name="without-stoppable"></a>Sans Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Avec Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Licence

MIT