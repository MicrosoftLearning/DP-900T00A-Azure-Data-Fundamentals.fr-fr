---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051177"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![téléchargements][downloads-image]][downloads-url] [![guide de style javascript][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>API de mémoire tampon Node.js plus sûre

**Utilisez les nouvelles API de mémoire tampon Node.js (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) dans toutes les versions de Node.js.**

**Utilise l’implémentation intégrée quand elle est disponible.**

## <a name="install"></a>installer

```
npm install safe-buffer
```

## <a name="usage"></a>usage

L’objectif de ce package est de fournir un remplacement sûr pour le `Buffer` node.js.

Il s’agit d’un remplacement de type « drop-in » pour `Buffer`. Vous pouvez l’utiliser en ajoutant une ligne `require` en haut de vos modules node.js :

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Méthode de classe : Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

Alloue un nouveau `Buffer` en utilisant un `array` d’octets.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

Une erreur `TypeError` est levée si `array` n’est pas un `Array`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Méthode de classe : Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} La propriété `.buffer` d’un `TypedArray` ou d’un `new ArrayBuffer()`
* `byteOffset` {Number} Par défaut : `0`
* `length` {Number} Par défaut : `arrayBuffer.length - byteOffset`

Si vous avez passé une référence à la propriété `.buffer` d’une instance `TypedArray`, le `Buffer` nouvellement créé partage la même mémoire allouée que TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Les arguments facultatifs `byteOffset` et `length` spécifient une plage de mémoire dans le `arrayBuffer` partagée par le `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

Une erreur `TypeError` est levée si `arrayBuffer` n’est pas un `ArrayBuffer`.

### <a name="class-method-bufferfrombuffer"></a>Méthode de classe : Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Copie les données `buffer` passées dans une nouvelle instance `Buffer`.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

Une erreur `TypeError` est levée si `buffer` n’est pas un `Buffer`.

### <a name="class-method-bufferfromstr-encoding"></a>Méthode de classe : Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} Chaîne à coder.
* `encoding` {String} Codage à utiliser. Par défaut : `'utf8'`

Crée un `Buffer` contenant la chaîne JavaScript `str` donnée. Si spécifié, le paramètre `encoding` identifie le codage de caractères.
Si non spécifié, `encoding` est défini par défaut sur `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

Une erreur `TypeError` est levée si `str` n’est pas une chaîne.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Méthode de classe : Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} Par défaut : `undefined`
* `encoding` {String} Par défaut : `utf8`

Alloue un nouveau `Buffer` de `size` octets. Si `fill` est `undefined`, `Buffer` est *rempli de zéros*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` doit être inférieur ou égal à la valeur de `require('buffer').kMaxLength` (sur les architectures 64 bits, `kMaxLength` est `(2^31)-1`). Sinon, une erreur [`RangeError`][] est levée. Une mémoire tampon de longueur nulle est créée si une `size` spécifiée est inférieure ou égale à 0.

Si `fill` est spécifié, le `Buffer` alloué est initialisé par l’appel de `buf.fill(fill)`. Pour plus d’informations, consultez [`buf.fill()`][].

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Si `fill` et `encoding` sont spécifiés, le `Buffer` alloué est initialisé par l’appel de `buf.fill(fill, encoding)`. Par exemple :

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

L’appel de `Buffer.alloc(size)` peut être beaucoup plus lent que son alternative `Buffer.allocUnsafe(size)`. Toutefois, il garantit que le contenu de l’instance `Buffer` nouvellement créée *ne contient jamais de données sensibles*.

Une erreur `TypeError` est levée si `size` n’est pas un nombre.

### <a name="class-method-bufferallocunsafesize"></a>Méthode de classe : Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Alloue un nouveau `Buffer` *non rempli de zéros* de `size` octets.  `size` doit être inférieur ou égal à la valeur de `require('buffer').kMaxLength` (sur les architectures 64 bits, `kMaxLength` est `(2^31)-1`). Sinon, une erreur [`RangeError`][] est levée. Une mémoire tampon de longueur nulle est créée si une `size` spécifiée est inférieure ou égale à 0.

Pour les instances `Buffer` créées de cette façon, la mémoire sous-jacente *n’est pas initialisée*. Le contenu du `Buffer` nouvellement créé est inconnu et *peut contenir des données sensibles*. Utilisez [`buf.fill(0)`][] pour initialiser ces instances `Buffer` avec des zéros.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

Une erreur `TypeError` est levée si `size` n’est pas un nombre.

Notez que le module `Buffer` préalloue une instance `Buffer` interne de taille `Buffer.poolSize` qui est utilisée comme pool pour l’allocation rapide de nouvelles instances `Buffer` créées en utilisant `Buffer.allocUnsafe(size)` (et le constructeur déprécié `new Buffer(size)`) uniquement quand `size` est inférieure ou égale à `Buffer.poolSize >> 1` (plancher de `Buffer.poolSize` divisé par deux). La valeur par défaut de `Buffer.poolSize` est `8192`, mais elle peut être modifiée.

L’utilisation de ce pool de mémoires interne préalloué est ce qui distingue principalement l’appel de `Buffer.alloc(size, fill)` de l’appel de `Buffer.allocUnsafe(size).fill(fill)`. En particulier, `Buffer.alloc(size, fill)` n’utilise *jamais* le pool de mémoires tampons interne, alors que `Buffer.allocUnsafe(size).fill(fill)` l’*utilise* si `size` est inférieure ou égale à la moitié de `Buffer.poolSize`. La différence est subtile, mais peut avoir son importance quand une application nécessite les performances supplémentaires que fournit `Buffer.allocUnsafe(size)`.

### <a name="class-method-bufferallocunsafeslowsize"></a>Méthode de classe : Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Alloue un nouveau `Buffer` *non rempli de zéros* et non mis en pool de `size` octets.  `size` doit être inférieur ou égal à la valeur de `require('buffer').kMaxLength` (sur les architectures 64 bits, `kMaxLength` est `(2^31)-1`). Sinon, une erreur [`RangeError`][] est levée. Une mémoire tampon de longueur nulle est créée si une `size` spécifiée est inférieure ou égale à 0.

Pour les instances `Buffer` créées de cette façon, la mémoire sous-jacente *n’est pas initialisée*. Le contenu du `Buffer` nouvellement créé est inconnu et *peut contenir des données sensibles*. Utilisez [`buf.fill(0)`][] pour initialiser ces instances `Buffer` avec des zéros.

Quand vous utilisez `Buffer.allocUnsafe()` pour allouer de nouvelles instances `Buffer`, les allocations inférieures à 4 Ko sont, par défaut, découpées à partir d’un seul `Buffer`préalloué. Cela permet aux applications d’éviter la surcharge de garbage collection liée à la création de nombreuses mémoires tampons allouées individuellement. Cette approche améliore les performances et l’utilisation de la mémoire en évitant d’avoir à suivre et nettoyer autant d’objets `Persistent`.

Toutefois, si un développeur a besoin de conserver un petit bloc de mémoire de pool pour une durée indéterminée, il peut avoir à créer une instance de mémoire tampon hors pool en utilisant `Buffer.allocUnsafeSlow()`, puis copier les bits pertinents.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

`Buffer.allocUnsafeSlow()` ne doit être utilisé qu’en dernier recours, et seulement *après* qu’un développeur a observé une conservation de mémoire indue dans ses applications.

Une erreur `TypeError` est levée si `size` n’est pas un nombre.

### <a name="all-the-rest"></a>Tout le reste

Le reste de l’API `Buffer` est exactement le même que dans node.js.
[Consultez la documentation](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Liens connexes

- [Problème Node.js : Buffer(number) n’est pas sûr](https://github.com/nodejs/node/issues/4660)
- [Proposition d’amélioration de Node.js : dépréciation temporaire de Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer()](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>Pourquoi `Buffer` n’est pas sûr ?

Aujourd’hui, le constructeur node.js `Buffer` est surchargé, car il traite de nombreux types d’arguments différents comme `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array`, etc.), `ArrayBuffer`, mais aussi `Number`.

L’API est optimisée pour des raisons pratiques : quelque soit le type que vous utilisez, elle essaie de faire ce que vous voulez.

Le constructeur Buffer est si puissant que vous pouvez voir souvent du code de ce type :

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***Mais que se passe-t-il si `toHex` est appelé avec un argument `Number` ?***

### <a name="remote-memory-disclosure"></a>Divulgation de mémoire à distance

Si un attaquant peut obliger votre programme à appeler le constructeur `Buffer` avec un argument `Number`, il peut lui faire allouer une mémoire non initialisée du processus node.js.
Cela peut potentiellement divulguer des clés privées TLS, des données utilisateur ou des mots de passe de base de données.

Quand le constructeur `Buffer` reçoit un argument `Number`, il retourne un bloc **NON INITIALISÉ** de mémoire avec la `size` spécifiée. Quand vous créez un `Buffer` de ce type, vous **DEVEZ** remplacer le contenu avant de le renvoyer à l’utilisateur.

Dans la [documentation node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size) :

> `new Buffer(size)`
>
> - `size` Nombre
>
> Pour les instances `Buffer` créées de cette façon, la mémoire sous-jacente n’est pas initialisée.
> **Le contenu du `Buffer` nouvellement créé est inconnu et peut comprendre des données sensibles.** Utilisez `buf.fill(0)` pour initialiser une mémoire tampon avec des zéros.

(Mettre l’accent sur le nôtre.)

Chaque fois que le programmeur veut créer un `Buffer` non initialisé, vous voyez souvent du code de ce type :

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>Est-ce que ce sera toujours un problème dans le code réel ?

Oui. Étonnamment, on oublie souvent de vérifier le type de nos variables dans un langage typé dynamiquement comme JavaScript.

En règle générale, quand vous supposez le mauvais type, votre programme se bloque avec une exception non interceptée. Toutefois, l’échec lié à l’oubli de vérification du type des arguments sur le constructeur `Buffer` est plus catastrophique.

Voici un exemple de service vulnérable qui prend une charge utile JSON et la convertit au format hexadécimal :

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

Dans cet exemple, un client HTTP doit simplement envoyer :

```json
{
  "str": 1000
}
```

pour récupérer 1 000 octets de mémoire non initialisée sur le serveur.

C’est un bogue très grave. Il est aussi grave que le [bogue Heartbleed](http://heartbleed.com/) qui a permis à des attaquants distants de divulguer la mémoire du processus OpenSSL.


### <a name="which-real-world-packages-were-vulnerable"></a>Quels sont les packages réels qui étaient vulnérables ?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) and moi-même ([Feross Aboukhadijeh](http://feross.org/)) avons repéré ce problème dans l’un de nos propres packages, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). Le bogue permettait à toute personne sur Internet d’envoyer une série de messages à un utilisateur de `bittorrent-dht` et de l’amener à révéler 20 octets à la fois de mémoire non initialisée du processus node.js.

Voici [le commit](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) qui l’a corrigé. Nous avons publié une nouvelle version corrigée, créé une [divulgation Node Security Project](https://nodesecurity.io/advisories/68) et déprécié toutes les versions vulnérables sur npm afin que les utilisateurs reçoivent un avertissement pour faire la mise à niveau vers une version plus récente.

#### [`ws`](https://www.npmjs.com/package/ws)

Cela nous a conduit à nous demander s’il y avait d’autres paquets vulnérables. Bien sûr, en peu de temps, nous avons trouvé le même problème dans [`ws`](https://www.npmjs.com/package/ws), l’implémentation WebSocket la plus connue dans node.js.

Si certaines API sont appelées avec des paramètres `Number` au lieu de `String` ou `Buffer` comme prévu, la mémoire de serveur non initialisée est divulguée au pair distant.

Les méthodes suivantes sont celles qui étaient vulnérables :

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Voici un serveur de socket vulnérable avec des fonctionnalités d’écho :

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

`socket.send(number)` appelé sur le serveur, divulgue la mémoire du serveur.

Voici [la version](https://github.com/websockets/ws/releases/tag/1.0.1) où le problème a été résolu, avec une explication plus détaillée. Bravo à [Arnout Kazemier](https://github.com/3rd-Eden) pour la correction rapide. Voici la [divulgation Node Security Project](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>Quelle est la solution ?

Il est important que node.js offre un moyen rapide d’obtenir de la mémoire, sans quoi les applications qui ont déjà des mauvaises performances sont inutilement encore plus lentes.

Nous avons besoin d’un meilleur moyen pour *indiquer notre intention* en tant que programmeurs. **Quand nous voulons de la mémoire non initialisée, nous devons pouvoir la demander explicitement.**

Les fonctionnalités sensibles ne doivent pas être empaquetées dans une API probablement conviviale pour les développeurs, mais qui accepte sans limite de nombreux types différents. Ce genre d’API encourage le passage de variables sans vérifier très attentivement le type.

#### <a name="a-new-api-bufferallocunsafenumber"></a>Une nouvelle API : `Buffer.allocUnsafe(number)`

La fonctionnalité qui permet de créer des mémoires tampons avec une mémoire non initialisée doit faire partie d’une autre API. Nous proposons `Buffer.allocUnsafe(number)`. De cette façon, elle n’est pas intégrée à une API dans laquelle l’utilisateur peut passer toutes sortes de types différents.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>Comment corriger node.js core ?

Nous avons envoyé [une PR à Node.js Core](https://github.com/nodejs/node/pull/4514) (fusionnée sous `semver-major`) qui se défend contre un cas :

```js
var str = 16
new Buffer(str, 'utf8')
```

Dans ce cas, on suppose que le programmeur voulait que le premier argument soit une chaîne, puisqu’il a passé un codage comme deuxième argument. Aujourd’hui, node.js alloue de la mémoire non initialisée dans le cas de `new Buffer(number, encoding)`, ce qui n’est probablement pas ce que le programmeur voulait.

Toutefois, ce n’est qu’une solution partielle, car si le programmeur utilise `new Buffer(variable)` (sans paramètre `encoding`) il n’y a aucun moyen de savoir ce qu’il voulait faire. Si `variable` est parfois un nombre, de la mémoire non initialisée est parfois retournée.

### <a name="whats-the-real-long-term-fix"></a>Quelle est la véritable correction à long terme ?

Nous pourrions déprécier et supprimer `new Buffer(number)` pour utiliser `Buffer.allocUnsafe(number)` quand nous avons besoin de mémoire non initialisée. Mais cela interromprait des milliers de paquets.

~~Nous pensons que la meilleure solution est de :~~

~~1. Changer `new Buffer(number)` pour retourner une mémoire sans zéros, sûre~~

~~2. Créer une API pour la création de mémoires tampons non initialisées. Nous proposons : `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Update

Nous prenons désormais en charge l’ajout de trois nouvelles API :

- `Buffer.from(value)` : convertit n’importe quel type en mémoire tampon
- `Buffer.alloc(size)` : crée une mémoire tampon remplie de zéros
- `Buffer.allocUnsafe(size)` : crée une mémoire tampon non initialisée avec une taille donnée

Cela résout le problème principal qui affectait `ws` et `bittorrent-dht` (`Buffer(variable)` était induit en erreur et prenait un argument numérique).

De cette façon, le code existant continue de fonctionner et l’impact sur l’écosystème npm est minime. Au fil du temps, les responsables de la maintenance npm peuvent ajouter `Buffer.allocUnsafe(number)` au lieu de `new Buffer(number)` dans le code critique pour les performances.


### <a name="conclusion"></a>Conclusion

Nous pensons qu’il y a un sérieux problème de conception avec l’API `Buffer` telle qu’elle existe aujourd’hui. Elle encourage les logiciels non sécurisés en plaçant des fonctionnalités à haut risque dans une API pratique dotée d’une « ergonomie conviviale pour les développeurs ».

Ce n’est pas seulement un exercice théorique, parce que nous avons trouvé le problème dans certains des packages npm les plus utilisés.

Heureusement, il existe aujourd’hui un correctif facile. Utilisez `safe-buffer` au lieu de `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

À terme, nous espérons que node.js core pourra basculer vers ce nouveau comportement plus sûr. Nous pensons que l’impact sur l’écosystème sera minime, puisqu’il ne s’agit pas d’un changement cassant.
Les packages populaires bien gérés seront mis à jour pour utiliser `Buffer.alloc` rapidement, tandis que les packages plus anciens et non sécurisés deviendront protégés comme par magie contre ce vecteur d’attaque.


## <a name="links"></a>liens

- [PR Node.js : mémoire tampon : levée si la longueur et le codage sont passés](https://github.com/nodejs/node/pull/4514)
- [Divulgation Node Security Project pour `ws`](https://nodesecurity.io/advisories/67)
- [Divulgation Node Security Project pour `bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>crédits

Les problèmes d’origine dans `bittorrent-dht` ([divulgation](https://nodesecurity.io/advisories/68)) et `ws` ([divulgation](https://nodesecurity.io/advisories/67)) ont été découverts par [Mathias Buus](https://github.com/mafintosh) et [Feross Aboukhadijeh](http://feross.org/).

Merci à [Adam Baldwin](https://github.com/evilpacket) pour son aide dans la divulgation de ces problèmes et pour son travail sur [Node Security Project](https://nodesecurity.io/).

Merci à [John Hiesey](https://github.com/jhiesey) pour la vérification de ce README et l’audit du code.


## <a name="license"></a>license

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
