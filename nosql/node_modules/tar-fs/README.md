---
ms.openlocfilehash: 841a4ef811cc186a2302309fbbc4a380d1ba5cbd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050433"
---
# <a name="tar-fs"></a>tar-fs

liaisons de système de fichiers pour [tar-stream](https://github.com/mafintosh/tar-stream).

```
npm install tar-fs
```

[![État de la build](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## <a name="usage"></a>Usage

tar-fs vous permet de compresser des répertoires dans des tarballs et d’extraire des tarballs dans des répertoires.

Il ne fait pas de gunzip pour vous, donc si vous voulez l’utiliser pour extraire un `.tar.gz`, vous devez choisir en plus quelque chose comme [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe).

``` js
var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
```

Pour ignorer différents fichiers pendant la compression ou l’extraction, ajoutez une fonction ignore aux options. `ignore` est également un alias de `filter`. Par ailleurs, vous obtenez `header` si vous utilisez ignore pendant l’extraction.
De cette façon, vous pouvez également filtrer en fonction des métadonnées.

``` js
var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files & directories, ignore e.g. symlinks
    return header.type !== 'file' && header.type !== 'directory'
  }
})
```

Vous pouvez également spécifier les entrées à compresser en utilisant l’option `entries`

```js
var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
```

Si vous voulez modifier les en-têtes pendant la compression/l’extraction, ajoutez une fonction map aux options

``` js
var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
```

De même, vous pouvez utiliser `mapStream` pour modifier les flux de fichiers d’entrée/de sortie

``` js
var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

Définissez `options.fmode` et `options.dmode` pour que les fichiers/répertoires extraits aient les modes correspondants

``` js
var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

Il peut être utile d’utiliser `dmode` et `fmode` si vous compressez/décompressez des tarballs entre *nix/windows, pour que tous les fichiers/répertoires décompressés soient lisibles.

Vous pouvez également définir `options.readable` et/ou `options.writable`, afin que dmode et fmode soient accessibles en lecture/écriture.

``` js
var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

Définissez `options.strict` sur `false` pour ignorer les erreurs liées aux types d’entrée non pris en charge (comme les fichiers d’appareil)

Pour déréférencer les liens symboliques (compresser le contenu du lien symbolique au lieu du lien lui-même) définissez `options.dereference` sur `true`.

## <a name="copy-a-directory"></a>Copier un répertoire

La copie d’un répertoire avec des autorisations et mtime intact est aussi simple que

``` js
tar.pack('source-directory').pipe(tar.extract('dest-directory'))
```

## <a name="interaction-with-tar-stream"></a>Interaction avec [`tar-stream`](https://github.com/mafintosh/tar-stream)

Utilisez `finalize: false` et le hook `finish` pour laisser le flux pack ouvert pour d’autres entrées (voir [`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)), et utilisez `pack` pour passer un flux pack existant.

``` js
var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, "hello")
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
```


## <a name="performance"></a>Performances

La compression et l’extraction d’un répertoire de 6,1 Go avec 2496 répertoires et 2398 fichiers donnent les résultats suivants sur mon Macbook Air.
[Consultez le benchmark ici](https://gist.github.com/mafintosh/8102201)

* tar-fs : 34,261 secondes
* [node-tar](https://github.com/isaacs/node-tar) : 366,123 secondes (ou 10x plus lent)

## <a name="license"></a>Licence

MIT
