---
ms.openlocfilehash: c6dc9b216d8255c51f2dc575a7c59dce25deff9e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051063"
---
<!--
  -- This file is auto-generated from README_js.md. Changes should be made there.
  -->

# <a name="uuid-cihttpsgithubcomuuidjsuuidactionsqueryworkflow3aci-browserhttpsgithubcomuuidjsuuidactionsqueryworkflow3abrowser"></a>uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Browser](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ABrowser)

Pour la création d’UUID [RFC4122](http://www.ietf.org/rfc/rfc4122.txt)

- **Complet** - Prise en charge de RFC4122 version 1, 3, 4 et 5, et de 5 UUID
- **Multiplateforme** - Prise en charge de...
  - CommonJS, les [modules ECMAScript](#ecmascript-modules) et les [builds CDN](#cdn-builds)
  - Node 8, 10, 12, 14
  - Navigateurs Chrome, Safari, Firefox, Edge, IE 11
  - Bundlers de modules Webpack et rollup.js
  - [React Native / Expo](#react-native--expo)
- **Sécurisé** - Valeurs aléatoires fortement chiffrées
- **Petit** - aucune dépendance, petite empreinte mémoire, s’adapte bien aux packagers de type « tree shaking »
- **CLI** - Comprend l’utilitaire [de ligne de commande`uuid`](#command-line)

**Vous faites une mise à niveau d’`uuid@3.x` ?** Votre code est probablement correct, mais consultez [Mise à niveau d’`uuid@3.x`](#upgrading-from-uuid3x) pour plus d’informations.

## <a name="quickstart"></a>Démarrage rapide

Pour créer un UUID aléatoire...

**1. Installer**

```shell
npm install uuid
```

**2. Créer un UUID** (syntaxe de module ES6)

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

... ou en utilisant la syntaxe CommonJS :

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Pour les UUID timestamp, les UUID d’espace de noms et d’autres options lues sur...

## <a name="api-summary"></a>Synthèse d’API

|  |  |  |
| --- | --- | --- |
| [`uuid.NIL`](#uuidnil) | Chaîne UUID nil (que des zéros) | Nouveautés dans `uuid@8.3` |
| [`uuid.parse()`](#uuidparsestr) | Convertir une chaîne UUID en tableau d’octets | Nouveautés dans `uuid@8.3` |
| [`uuid.stringify()`](#uuidstringifyarr-offset) | Convertir un tableau d’octets en chaîne UUID | Nouveautés dans `uuid@8.3` |
| [`uuid.v1()`](#uuidv1options-buffer-offset) | Créer un UUID version 1 (timestamp) |  |
| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | Créer un UUID version 3 (espace de noms avec MD5) |  |
| [`uuid.v4()`](#uuidv4options-buffer-offset) | Créer un UUID version 4 (aléatoire) |  |
| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | Créer un UUID version 5 (espace de noms avec SHA-1) |  |
| [`uuid.validate()`](#uuidvalidatestr) | Tester une chaîne pour voir s’il s’agit d’un UUID valide | Nouveautés dans `uuid@8.3` |
| [`uuid.version()`](#uuidversionstr) | Détecter la version RFC d’un UUID | Nouveautés dans `uuid@8.3` |

## <a name="api"></a>API

### <a name="uuidnil"></a>uuid.NIL

Chaîne UUID nil (que des zéros).

Exemple :

```javascript
import { NIL as NIL_UUID } from 'uuid';

NIL_UUID; // ⇨ '00000000-0000-0000-0000-000000000000'
```

### <a name="uuidparsestr"></a>uuid.parse(str)

Convertir une chaîne UUID en tableau d’octets

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | UUID `String` valide                    |
| _retourne_ | `Uint8Array[16]`                         |
| _lève_  | `TypeError` si `str` n’est pas un UUID valide |

Remarque : Le classement des valeurs dans les tableaux d’octets utilisés par `parse()` et `stringify()` suit l’ordre gauche &Rarr; droite des paires hexadécimales dans les chaînes UUID. Comme illustré dans l’exemple ci-dessous.

Exemple :

```javascript
import { parse as uuidParse } from 'uuid';

// Parse a UUID
const bytes = uuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b');

// Convert to hex strings to show byte order (for documentation purposes)
[...bytes].map((v) => v.toString(16).padStart(2, '0')); // ⇨ 
  // [
  //   '6e', 'c0', 'bd', '7f',
  //   '11', 'c0', '43', 'da',
  //   '97', '5e', '2a', '8a',
  //   'd9', 'eb', 'ae', '0b'
  // ]
```

### <a name="uuidstringifyarr-offset"></a>uuid.stringify(arr[, offset])

Convertir un tableau d’octets en chaîne UUID

|                |                                                                              |
| -------------- | ---------------------------------------------------------------------------- |
| `arr`          | Collection de type `Array` de 16 valeurs (à partir de `offset`) entre 0 et 255. |
| [`offset` = 0] | `Number` Index de départ du tableau                                         |
| _retourne_      | `String`                                                                     |
| _lève_       | `TypeError` si une chaîne UUID valide ne peut pas être générée                       |

Remarque : Le classement des valeurs dans les tableaux d’octets utilisés par `parse()` et `stringify()` suit l’ordre gauche &Rarr; droite des paires hexadécimales dans les chaînes UUID. Comme illustré dans l’exemple ci-dessous.

Exemple :

```javascript
import { stringify as uuidStringify } from 'uuid';

const uuidBytes = [
  0x6e,
  0xc0,
  0xbd,
  0x7f,
  0x11,
  0xc0,
  0x43,
  0xda,
  0x97,
  0x5e,
  0x2a,
  0x8a,
  0xd9,
  0xeb,
  0xae,
  0x0b,
];

uuidStringify(uuidBytes); // ⇨ '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'
```

### <a name="uuidv1options-buffer-offset"></a>uuid.v1([options[, buffer[, offset]]])

Créer un UUID RFC version 1 (timestamp)

|  |  |
| --- | --- |
| [`options`] | `Object` avec une ou plusieurs des propriétés suivantes : |
| [`options.node` ] | Champ RFC « node » de type `Array[6]` avec des valeurs d’octets (d’après 4.1.6) |
| [`options.clockseq`] | Champ « clock sequence » RFC de type `Number` entre 0 et 0x3fff |
| [`options.msecs`] | Champ RFC « timestamp » (`Number` millisecondes, époque unix) |
| [`options.nsecs`] | Champ RFC « timestamp » (`Number` nanosecondes à ajouter à `msecs`, doit être entre 0 et 10 000) |
| [`options.random`] | `Array` de 16 octets aléatoires (0-255) |
| [`options.rng`] | Alternative à `options.random`, une `Function` qui retourne un `Array` de 16 octets aléatoires (0-255) |
| [`buffer`] | `Array \| Buffer` Si spécifié, uuid est écrit ici sous forme d’octets, à partir de `offset` |
| [`offset` = 0] | `Number` Index de départ pour écrire des octets UUID dans `buffer` |
| _retourne_ | UUID `String` si aucun `buffer` n’est spécifié, sinon retourne `buffer` |
| _lève_ | `Error` si plus de 10 millions d’UUID/s sont demandés |

Remarque : L’[ID de nœud](https://tools.ietf.org/html/rfc4122#section-4.1.6) par défaut (les 12 derniers chiffres de l’UUID) est généré une fois, de manière aléatoire, au démarrage du processus, puis reste inchangé pendant la durée du processus.

Remarque : `options.random` et `options.rng` ont du sens seulement dans le tout premier appel de `v1()`, où ils peuvent être passés pour initialiser les champs internes `node` et `clockseq`.

Exemple :

```javascript
import { v1 as uuidv1 } from 'uuid';

uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

Exemple utilisant `options` :

```javascript
import { v1 as uuidv1 } from 'uuid';

const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678,
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'
```

### <a name="uuidv3name-namespace-buffer-offset"></a>uuid.v3(name, namespace[, buffer[, offset]])

Créer un UUID RFC version 3 (espace de noms avec MD5)

L’API est identique à `v5()`, mais utilise « v3 » à la place.

&#x26a0;&#xfe0f; Remarque : D’après RFC, « _Si la compatibilité descendante n’est pas un problème, SHA-1 [version 5] est préféré_ ».

### <a name="uuidv4options-buffer-offset"></a>uuid.v4([options[, buffer[, offset]]])

Créer un UUID RFC version 4 (aléatoire)

|  |  |
| --- | --- |
| [`options`] | `Object` avec une ou plusieurs des propriétés suivantes : |
| [`options.random`] | `Array` de 16 octets aléatoires (0-255) |
| [`options.rng`] | Alternative à `options.random`, une `Function` qui retourne un `Array` de 16 octets aléatoires (0-255) |
| [`buffer`] | `Array \| Buffer` Si spécifié, uuid est écrit ici sous forme d’octets, à partir de `offset` |
| [`offset` = 0] | `Number` Index de départ pour écrire des octets UUID dans `buffer` |
| _retourne_ | UUID `String` si aucun `buffer` n’est spécifié, sinon retourne `buffer` |

Exemple :

```javascript
import { v4 as uuidv4 } from 'uuid';

uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Exemple utilisant des valeurs `random` prédéfinies :

```javascript
import { v4 as uuidv4 } from 'uuid';

const v4options = {
  random: [
    0x10,
    0x91,
    0x56,
    0xbe,
    0xc4,
    0xfb,
    0xc1,
    0xea,
    0x71,
    0xb4,
    0xef,
    0xe1,
    0x67,
    0x1c,
    0x58,
    0x36,
  ],
};
uuidv4(v4options); // ⇨ '109156be-c4fb-41ea-b1b4-efe1671c5836'
```

### <a name="uuidv5name-namespace-buffer-offset"></a>uuid.v5(name, namespace[, buffer[, offset]])

Créer un UUID RFC version 5 (espace de noms avec SHA-1)

|  |  |
| --- | --- |
| `name` | `String \| Array` |
| `namespace` | UUID d’espace de noms `String \| Array[16]` |
| [`buffer`] | `Array \| Buffer` Si spécifié, uuid est écrit ici sous forme d’octets, à partir de `offset` |
| [`offset` = 0] | `Number` Index de départ pour écrire des octets UUID dans `buffer` |
| _retourne_ | UUID `String` si aucun `buffer` n’est spécifié, sinon retourne `buffer` |

Remarque : Les espaces de noms RFC `DNS` et `URL` sont disponibles sous `v5.DNS` et `v5.URL`.

Exemple avec un espace de noms personnalisé :

```javascript
import { v5 as uuidv5 } from 'uuid';

// Define a custom namespace.  Readers, create your own using something like
// https://www.uuidgenerator.net/
const MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

uuidv5('Hello, World!', MY_NAMESPACE); // ⇨ '630eb68f-e0fa-5ecc-887a-7c7a62614681'
```

Exemple avec un espace de noms `URL` RFC :

```javascript
import { v5 as uuidv5 } from 'uuid';

uuidv5('https://www.w3.org/', uuidv5.URL); // ⇨ 'c106a26a-21bb-5538-8bf2-57095d1976c1'
```

### <a name="uuidvalidatestr"></a>uuid.validate(str)

Tester une chaîne pour voir s’il s’agit d’un UUID valide

|           |                                                     |
| --------- | --------------------------------------------------- |
| `str`     | `String` à valider                                |
| _retourne_ | `true` si la chaîne est un UUID valide, sinon `false` |

Exemple :

```javascript
import { validate as uuidValidate } from 'uuid';

uuidValidate('not a UUID'); // ⇨ false
uuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ true
```

En utilisant `validate` et `version` ensemble, il est possible d’effectuer une validation par version, par exemple, pour valider uniquement les UUID v4.

```javascript
import { version as uuidVersion } from 'uuid';
import { validate as uuidValidate } from 'uuid';

function uuidValidateV4(uuid) {
  return uuidValidate(uuid) && uuidVersion(uuid) === 4;
}

const v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';
const v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';

uuidValidateV4(v4Uuid); // ⇨ true
uuidValidateV4(v1Uuid); // ⇨ false
```

### <a name="uuidversionstr"></a>uuid.version(str)

Détecter la version RFC d’un UUID

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | UUID `String` valide                    |
| _retourne_ | `Number` Version RFC de l’UUID     |
| _lève_  | `TypeError` si `str` n’est pas un UUID valide |

Exemple :

```javascript
import { version as uuidVersion } from 'uuid';

uuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // ⇨ 1
uuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ 4
```

## <a name="command-line"></a>Ligne de commande

Les UUID peuvent être générés à partir de la ligne de commande en utilisant `uuid`.

```shell
$ uuid
ddeb27fb-d9a0-4624-be4d-4615062daed4
```

La valeur par défaut génère des UUID version 4, mais les autres versions sont prises en charge. Tapez `uuid --help` pour plus de détails :

```shell
$ uuid --help

Usage:
  uuid
  uuid v1
  uuid v3 <name> <namespace uuid>
  uuid v4
  uuid v5 <name> <namespace uuid>
  uuid --help

Note: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs
defined by RFC4122
```

## <a name="ecmascript-modules"></a>Modules ECMAScript

Cette bibliothèque est fournie avec la prise en charge des [modules ECMAScript](https://www.ecma-international.org/ecma-262/6.0/#sec-modules) (ESM) pour les versions Node.js qui la prennent en charge ([exemple](./examples/node-esmodules/)) ainsi que des bundlers comme [rollup.js](https://rollupjs.org/guide/en/#tree-shaking) ([exemple](./examples/browser-rollup/)) et [webpack](https://webpack.js.org/guides/tree-shaking/) ([exemple](./examples/browser-webpack/)) (ciblant les deux, Node.js et les environnements de navigateur).

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Pour exécuter les exemples, vous devez d’abord créer une build dist de cette bibliothèque à la racine du module :

```shell
npm run build
```

## <a name="cdn-builds"></a>Builds CDN

### <a name="ecmascript-modules"></a>Modules ECMAScript

Pour charger ce module directement dans les navigateurs modernes qui [prennent en charge le chargement des modules ECMAScript](https://caniuse.com/#feat=es6-module), vous pouvez utiliser [jspm](https://jspm.org/) :

```html
<script type="module">
  import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
  console.log(uuidv4()); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
</script>
```

### <a name="umd"></a>UMD

Pour charger ce module directement dans des navigateurs plus anciens, vous pouvez utiliser les builds [UMD (Universal Module Definition)](https://github.com/umdjs/umd) à partir de l’un des CDN suivants :

**Avec [UNPKG](https://unpkg.com/uuid@latest/dist/umd/)**  :

```html
<script src="https://unpkg.com/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Avec [jsDelivr](https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/)**  :

```html
<script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Avec [cdnjs](https://cdnjs.com/libraries/uuid)**  :

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
```

Ces CDN fournissent tous la même méthode [`uuidv4()`](#uuidv4options-buffer-offset) :

```html
<script>
  uuidv4(); // ⇨ '55af1e37-0734-46d8-b070-a1e42e4fc392'
</script>
```

Les méthodes des autres algorithmes ([`uuidv1()`](#uuidv1options-buffer-offset), [`uuidv3()`](#uuidv3name-namespace-buffer-offset) et [`uuidv5()`](#uuidv5name-namespace-buffer-offset)) sont disponibles à partir des fichiers `uuidv1.min.js`, `uuidv3.min.js` et `uuidv5.min.js`, respectivement.

## <a name="getrandomvalues-not-supported"></a>« getRandomValues() non pris en charge »

Cette erreur se produit dans les environnements où l’API standard [`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) n’est pas prise en charge. Ce problème peut être résolu en ajoutant un polyfill approprié :

### <a name="react-native--expo"></a>React Native / Expo

1. Installez [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme)
1. Importez-le _avant_ `uuid`. Comme `uuid` peut également apparaître comme une dépendance transitive de certaines autres importations, il est plus sûr de simplement importer `react-native-get-random-values` avant toute chose dans votre point d’entrée :

```javascript
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
```

Remarque : Si vous utilisez Expo, vous devez utiliser au moins `react-native-get-random-values@1.5.0` et `expo@39.0.0`.

### <a name="web-workers--service-workers-edge--18"></a>Worker web / Workers du service (Edge <= 18)

[Dans Edge <= 18, Web Crypto n’est pas pris en charge dans les workers web ou les workers du service](https://caniuse.com/#feat=cryptography) et nous n’avons pas connaissance de l’existence d’un polyfill (dites-nous si vous en trouvez un, merci).

## <a name="upgrading-from-uuid7x"></a>Mise à niveau de d’`uuid@7.x`

### <a name="only-named-exports-supported-when-using-with-nodejs-esm"></a>Seules les exportations nommées sont prises en charge avec les modules ESM Node.js

`uuid@7.x` n’a pas de prise en charge native du module ECMAScript (ESM) pour Node.js. Son importation dans le module ESM Node.js importe donc la source CommonJS avec une exportation par défaut. Cette bibliothèque contient désormais une véritable prise en charge du modèle ESM Node.js et fournit uniquement des exportations nommées.

Au lieu de :

```javascript
import uuid from 'uuid';
uuid.v4();
```

vous devez maintenant utiliser les exportations nommées :

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

### <a name="deep-requires-no-longer-supported"></a>Les commandes require approfondies ne sont plus prises en charge

Les commandes require approfondies comme `require('uuid/v4')` [qui ont été dépréciées dans `uuid@7.x`](#deep-requires-now-deprecated) ne sont plus prises en charge.

## <a name="upgrading-from-uuid3x"></a>Mise à niveau de d’`uuid@3.x`

« _Attendez, que s’est-il passé avec `uuid@4.x` - `uuid@6.x` ?!?_  »

Pour éviter toute confusion avec les UUID RFC [version 4](#uuidv4options-buffer-offset) et [version 5](#uuidv5name-namespace-buffer-offset), et une éventuelle [version 6](http://gh.peabody.io/uuidv6/), les versions 4 à 6 de ce module ont été ignorées.

### <a name="deep-requires-now-deprecated"></a>Commandes require approfondies maintenant dépréciées

`uuid@3.x` encourage l’utilisation de commandes require approfondies pour réduire la taille de bundle des builds de navigateur :

```javascript
const uuidv4 = require('uuid/v4'); // <== NOW DEPRECATED!
uuidv4();
```

À partir d’`uuid@7.x`, cette bibliothèque fournit désormais des builds de modules ECMAScript, ce qui permet aux packagers comme Webpack et Rollup de faire un « tree-shaking » pour supprimer le code mort. À la place, utilisez la syntaxe `import` :

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

... ou pour CommonJS :

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4();
```

### <a name="default-export-removed"></a>Exportation par défaut supprimée

`uuid@3.x` exportait la méthode UUID version 4 sous forme d’exportation par défaut :

```javascript
const uuid = require('uuid'); // <== REMOVED!
```

Ce modèle d’utilisation était déjà déconseillé dans `uuid@3.x` et a été supprimé dans `uuid@7.x`.

----
Markdown généré à partir de [README_js.md](README_js.md) par [![RunMD Logo](http://i.imgur.com/h0FVyzU.png)](https://github.com/broofa/runmd)